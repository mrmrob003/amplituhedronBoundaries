(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["amplituhedronBoundaries`"];
SetDirectory[NotebookDirectory[]];
Image[CompressedData["
1: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
Rf2V/a1CSPwZaATZkSeCqZB/qr9dyNhYnN9HUwmyzmRv7O4e/e53q/ljaWkp
xMy1JJd8RFrMc+m0IE9hDCUl55kCJBXyeerBkv8aEn8GerF3by9brZY3KUFW
r/KUG6rbnXfW8ZRf2im40Wjse99LSI1dc03pwYPTvs0GCuIoHzEdhrn0dCBP
oTtkQeqjmAWp16K+K+3HQuLPQCMaGga5lsjcueW7dkVU63wmJiZ3NuHZMapt
hkW+Fy5MPPTQCR7ovvEGJuvqgUA+YjqYS19xxXHFXZoP+pldejqQp9AU8sY3
3ujmhqP+KvObNMO6aGAAAwOx/PyL4+zq1XXqzAegmvC9U/OmdEezyojFYvHk
l7c//SkSaqqTko8g8+WYj5iOw4fP/cVfvPP5zx++8kpFXfr//J/fXnLJga9/
/WguLj0dyFNoB/VFzzzTluzq1F9l/ZZhXTQwAPLkwsIenlybMaNk69bWSERk
6wevoLNTHagm/E011TDH0Z8+9sILZ7gbP/ZYs/qpwHDiST4ihcHB2JIlkxNi
v/Sl337ta0cVdOkvf3kyYPj4xw9+85vHqbYuD4s8hS5QL7R+fTPvl37+8zO5
W8qwLhqYQSQytm7dRZeeObN0y5bW4Jcu0hk3bz7Fs3h5U5utC+yd+pvf9HB/
huKTgniYj0iGnJYd8N57G3p6FHXpv//7Y9/+9uQeW9Truj9+Sp6CWhV5CtXg
qk1sxH/zTRHdWsO6aGAGx4/3L19exZ2B3Jti4/LyqN+b69Hx6SwsDv+HfyjO
+0BvgeojfMzDh89yx4bik1J4no9glJaeZwekR28+YUy6S/PYlbs09br85UBZ
mQcL8FPyFNS2yFOoQ7Jq06xZpe+9d87N0bg/Uz951VVK+LO/JwbKMz4e3727
d+XKau4YVBYvrnzuufaWlmFv3z7R0eiYzz7bTse/8sriL3zhyB//8cG/+It3
6ex79vS6zykkq4tA8UkF/MhHMHhWgsqvf92T/CdZLp18uhSXLixMTISjOtND
qCenRp5CQeyqTe6Pyfz5i1/8LfWW1GdSzyndnwGIxeJFRWdXrapJ9hMqS5dW
bdjQQr2Tm2wafXf//j46Dh2NH5k8/xOfOPjpTxd99avve/KamgHFJ3XwKR/B
SM5KpO02g3dpVuiMdN6U2W5UQ6on+4AnGQoG8hRKMZ1qk3soFKFjfuUr73/2
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
dU5eMjkdFRXR5M3g7GXGjMllFBrN6jfbXlpAt//Bg332Ba3TvbYyyWRcwZiX
++5rrK3VtfdLi0n2UpPz58e3bm1NniVoL3PmlOWofwJ7BQZ1fa+/3slt9Mwz
bepPVxsbi1M9eZ0LCroyxJO9vWNsOm6GgIEeD99775wWq2iNt5deTExMqk/c
dNPFyGHevPKU5KlhJuvoGEmeSHz33Q2Kb5bkFMPspSxdXaM7dpy54YYsis0U
lmfeVRb2ChKq59NPJ2o+a1bp4cM6KfpSbblcG7V/2jYn57nrrvrpvHHBgoqf
/awt+Mm0whhvL02hyGH//ouRw0MPneB/Ms9kfH77HXfUmbd2zDx7KQ510fS8
9i//0pThhUN+/onprgX2ChKq4eOPt/CHo6oq/R4WqM5cMJyuxd7mTz3VltYJ
7767/uDBPmV3YU5LGOylNRQ57NvXy9bmkHdZJpps9+7evCl5rrTqiLpjnr00
usW6u0dffLEjRQ2Jl7Qbu8BeQZIcni1aVKnvPGeq+Y03VqYN1Q4dOpvieHPn
lj/55Gkd5YvDYC8ziMXi+/b1rVlTf+7cuGEm+4d/KP72t48XFZ01z2oWbjE1
oMD76NH+hx8+kTIDbcaM1D1GYa+A4esIqLVVni6SC1R/rnhP18V+2dp6gS/R
pXLnnXX0iKSpCIMVAnsZxtSWH+2GmezKK4uvuspYk+EWU4re3rFXX+3k6yCo
XH99eXIeGfYKkr17e/n7HH3Ds2ToKvgCFrq64eEJNqH9uusm9xfTff2X8faS
XR3vgcn0AvZSE3roLik5v27dSbYm4rbbatk207BXkDQ0DLL2nzWrVMcE0HTQ
tbD5JHR1a9bUrVpVU1jYre8eB5ww2EvfRcppgcn0AvZSn/7+8V/8ouumm6rX
r2+GvYIkGh3nb3sCmGI6Oho/c2bM7w1BOHRFdF3f/vZxanndJbYYAduLovqO
jrHAMjjMXnlT2iZm2MsK3GRnz8ao+H0WjnkmC9hedHPRLRZYztowe1G7HTly
ju8WF4C9aPCiISywXd1Vs1eyfvIzz/iyTXky1JWVlQ0XFw9VV18YGgpoGOKz
YjIsz9GFgO1FvVlNzQWyV2npUCTiaoOY3DHJXlawJqPerKVllOxF5dSp0cAi
c5NMFvAtRrcV3Vxkr9raC4FF5rCXMDRs0eBF9qKBLLDIXCl77dzZzSqzenWd
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
jXh5/fUIq9Vrr3UKt4nKJnPZJZIzS7dRcqGb/dJLD03NZRKcfGIZbS8aLKTb
yF7E1O04vtqLBySRiIjelJpqWiMj4hFaJJJY2UotI3wQ/3Bjrzfe6Pqgt49I
t1Fy6eoSj/EUt5flwmT0jPC7v7tnan1cnXQb8XLzzZOyolSxgQHBxITiJnPZ
JZIzS7dRcnn11URS8pe/FJx8Yra9aLCQbiN7EVO3Y/htr4KCLnb8AwccC8Ba
SiqZ1NS4emjdv7+PNUhBgfhjlH+4sdfQUOz3fm8yRX7TTQqNQcXuJp8obi/L
ncmuuWZy5+LPfvZd6TbihSpDVZo5s1S4QRQ3mcsuUbUx6Kabal1OPjHbXgQN
GdLNlFyE1e0YfturoSGxkHPjxlOiR1ArPdHR4SoxsWFDC2uQxkbHC34DwKW9
Zs8uow7kM59RaAyqrXUV4yluL8udyV54IbHZ9M6dfdItReVXv+r9YCat+Bou
xU3mvktUKkV+2WXvkL3mzBGffGK8vWjIkG6m5CKsbsfw216xWHzevHI6vvAy
HNWUTC5cEF3UOrULJMsEUZsIr431FZf2euWVhOb8G2+okiJ3M/lEfXtZ7kx2
7tz4v//3u8let9/eIN1SVKgaVBmqElVMrDXUN5n7LlGdFPkbbyQmn7z6quAj
ZxjsRUOGdEslF2EFYysoe+XnJyS7W1qGBb6ulJJJdbWrh1ZqAdYU1CZujuMr
buwVjY7/x/84mSK/7TYlxqDiyRhP/C2cFvay3JnsO98pJnt9/vPvSbfU/2/v
TKCsKs59fzOs3Ny73nTz3nrmZrgr7+a9PL33rkxGEzO8aLLiCCoqIKAyR0WD
ghlQEYWOqKCCgIoT4JBo0kpiR0S6BZpJpqan002P9Ex306e76Xk+57yvu47F
9pzTu8+uPVXV+f9WLRYcztm7hm9X1a766vtT+vd/P0SZueqqHOGqUKLJbHaJ
8oxBd91VSu1Fj7yw/3wqtBdBA4fvjcWTnUNk3rRXdnY7u8vWrQ1iV5Anksnp
07Y2JrZsiUYV27fPsvSbZ9hsr8mTT1A3csEFB31vrBzbzidKtFfEXpO9/HL9
x4fr2/1trPfeiwqkvvKKYEcRUaTJ7HeJkmyRn3/+QWqva68Vdz5JkfaigcP3
xmLJTgTjiFftNTAQmjo1j+4ye3ahmIqWPJFMenvFl2NCoQjVANXDtGn5drzy
3MZme23bFt0iz8jwf4vczhxPlfaK2GuyYHDwM58Z3Z64775yfxtr6dJyygZl
prVVsNVUaTL7XaIMYxA94B8rnQk6n6ROe9HA4Xt7sWQnup2X7fXMMzVsclJQ
0CXwc0kimQQCggtTjPz8LlYJGzYI+tJ4hp32am8f+uxnR8egJUv8356wqnpv
RKH2ithrsp/97Bi113e+c9jfxvr2tw9TNn7+8+PClaBQk9nsEsmwfX+47r13
dI5HDzs98mKVkDrtRdDw4XuT5dg7ROZlexUVRSNwrlkjKJ0pQySThgZbGxNc
VrW4uNvOdTzAZntdfvlx6ky++c2P/G2voiJbczyF2itir8mefbaW2utTn/pg
166zfjUW3ZoyQNl47jmRIL0MhZrMfpfo+xhEDzi11xVXiDufpFR71df7vzRk
M7qdl+0VDkcWLSqme02efKKxUeSghwyuwj094i+tVGoqO9UA1YPY6paX2Gyv
F1+MbpHv3OnbGJRjb46nVntF7DUZfZ+N1/ffX+lXYy1bVsnmLU1NggfB1Goy
+10imbePD9f770edT156qV6sBlKtvWj48LG9WLIT3c779tq7NxoIYuNGEcVt
3yOZFBbaemndsCG6tJWdLa+rjxE77dXSMvjpT49uT/z2txU+Npkd5xPl2iti
r8l+/OOj1F4XX3zEr8aiW1MGfvKTo8LFV67JbHaJ/m6R06NN7UWPOT3sYsVP
tfYiaBDxscly7EUw9r69RkbCCxYU0R2vvz5XzMfJX1fhujrBRyMy5mZGpaay
L1xYZEcZxEtsttell45ukX/ve75tkdtxPlGxvSL2mmzduho2BOze3el9Y9FN
2SRTOGyOik1mv0v0cQy68MJR55PLLjsmVvbUbC8aRPxqrxx70e38aq9du6Ja
5M8+KzJP8zeaVne3+Evrpk21rOCZmXKpw5tjp71oKs7GoKysDl/aq75efBVO
0faK2Giy2tp+ttS8YkWV941FN2V3r6sT7NYUbTKbXWJ9vT9jUGZmB5vjUbWL
FTw124sGEV/aiyU7EYz9aq/h4fD8+QG2JVRRYTnspI+RTAoKxF9ay8t72DYQ
zVHtRPn2Hjvt1dAQHYMefPCUL00m7HyibntF7DXZRReNvjn+6EfHvG+sH/6Q
7YwcFiu1uk1ms0v0awx64IFT7Ok+fVpkZz9l24ugocSXJsuxEcHY3/Y6fryD
TVeWLi0V8KPwK5pWba3gxkQoFFmypIQVOSenU+wiPmKnvS65ZHSH+pJLjnrf
XsJzPNXbK2KjyR5/vIodncvO7vKysfbu7WKHc594QsQjXfUms9kl+jIG/eAH
o4/2D394RKC8Kd5eNJR43145NiIYy9Bejz56imVg586g1d/6Fcmkq0tQso3K
yAq7erXgCR3fEW6vJ5+sZiF69uzxeotc2PlEg/aKiDYZvTexl8e0tBovG2vV
qmp238pKkRc3DZrMTpfo/RY5Pc4sCNhTT1ULFDbF24uGEo/biyXh6HYytFcw
OHTTTaMxtaZNy7d6rqqzc2TTptOUjh7t8ay28/P7xI6WUOmojFRSKi+VWuQS
EiDcXlVVfWwsWLmy2uMHpKtLZBVOj/aK2Giyb33r0JhjW46XjXXppaPRPL79
7UMCJdWjyex0id6PQY88Ep3jCYgvoL1oKKEBxbPGooGSjZhir73ytNe7755h
U5clS0qS3x+hb7KAdZQuuuiwZ9OGmhqRl9ahofCSJaWsmBkZLQJXkAex9iK+
+93RqC8XXnjkT38Kepays0UW0HRqr4hok61aVTkmOZR14IBH2xP793d97nOZ
Y4sbliVvdGoy4UeMxiAyeC+fL3Zi4sILP7JaRrQXgwYUzyYMzEmJEg2dVvMp
VXuRnaelRZd3kg8JsmtXKys+SzR38qbmOzpEZmgvvlg/6WP9L/kjlpgj1l6R
sUU8Y5N5k1asOCVQRp3aKyLaZMXF3VSB//RPu19//Yw3DxfdiG5HNz15ssdq
GXVqMuFHjCCD9/4pW73a8lOG9mLQgOLNw0VDpLHJaAC1lE/Z2qu7e2TevADL
0sGDScWIiJkzWK0BL6ESsaJRGamkfmfHAQTai2huHjx2rNPj3mzdOstn/PVr
r4hokx06dNZj12i6Hd3U6q/0azKx9op8HFvDy0QPNT3alkqH9vIeOyOmnO1V
VtbDwkRMmZIbCEws/GHcmxBYafGMQKCbSjRpLPQHldHv7DiG1fZijIyE8/K6
vExWA9NRe7GTRJq1V0S0yeRH70fsyitzLLUXGbzHj5jVqD56t5e0z5fwiClz
e2VlRUNkTJ+en4xHDZWaJkuUpJ0wVFX1MacRSlQ6v7PjMFbbS36ovaZMyfvi
F/d885uH1AovkyRaNpmuj1g4HFm6tOSLX9x7xRU5aC8lkPz5Ehgx5W+v9PRm
lr3bbisUlqeRBMr/rbcWsuJQufzOjito1l633FL45S/vPe+8PRde+NHTT1dL
Oxe1g2ZNpusjRrb31FPVVC4yRbLJa65Be6kBni+Poak197WgOpdwqpYkND27
+eYC7hUjg9OIG+jUXuzpuPjiw9/61iFWolWrKu3oy8uJfk2m3yNGVke2x4o2
efKJxYtL0F6qwJ+vK6/MQXt5A+WNXvH4Co+EG0MTEgh003sBW+KmlwWZa9s+
erQXX3+jsmRnt193XS7757Jl5T09svj8OIV+TabTI0b29rvflbGiXX997v79
7WgvtQiFIlOnjm5x/uxnx9Be3mB8FZoyJVdON9TxYC6m5523hxLNGd58s8nv
HLmO6u3FPHyM0+mcnI4bb8xjH9Jb3tmzw35n02H0azI9IEvjqwpkgSdORKOL
oL0U4s03G6mk1PnTEHDFFTloL2+gfPKNIUr0vMi/uTw0FObP9fe/f/jCC6NL
3O+/bzmmqHKo3l5jG3ZNxqejpKTn5pujM+2FC4vOnBFXP5cT/ZpMdcjGyNJY
0cj2Sks/4aOO9lKCHTtaeHkffLAC7eUxWVmt7PTKpNEQW6Uyu5RQ3u69t4Sv
KFLO//SnJr4jqdY8Uxil2yv+OzU1fbfdVsi3kmtrxRXnpUWzJlOXGGOjfyb8
GtpLZg4caGcntSlR/x9Be/lBWVkPj5UxbVr+zp1B2WY+odCocgff/aHcskOs
xuVEaoL8fPV2tQRQt70S0txs9uqnB5o1mYrELGqZh0hCe8lJXl4nnx4Yl/TR
Xt7T3T2SllbJF0yWLCkpL5elRJQTrg06aSyupjFMFtnGk09GnZduuilPnmy7
irG9rrlGpfZKyNmzw7/61Um+xZybq55i74So+4hpwIkTnVadZyRvL/66qmV7
JaS8vJcpVVGK93uXvL20fL6oCTIyWnijTJ58YtOm2mDQzy1mujvlga9EUd4o
h/ETyOHh8MMPR3e1Zs4saGiQd23KQVh7XXVVzpe+tPdHPzqqUHslpKdn5Le/
PefKfuCA5eDG8qPuI6Y0+/e385fT3/2uLPlDOtK2149/fISe+p///JiW7ZWQ
+vr+GTOiL+mPPFKZ0G9B2vbS+/kKBodWr67iMyJ61jZurG1s9HoUpjtu2FDD
n/RJY2LiJtqg/f2hX/86qgg2d27AXzvxDLK9e+8tPf/8g+edt+fiiw8r1F4J
GRgIrVx57si8rn6tij5iirJjRwvvscWCgcjWXhdddJgdGbv00uMtLbq1V0Ko
P58zJ+qI8pvflFFHYfpludpL7+eLc/x4x/z5AV5YeujWrKnKz+8KmbWVA9D1
6S50L/6YU1qwoIjyM+Fvu7qGFy0qZj+5885iMflyteCyJpMm5fBnSpX2SggP
zTfpYx8nzebkHOMjdsUVOR432RNPONZk0kKW89ZbTbyMZFd2nOrl6RKvvjrn
G9/Y/5OfHKG/C2iNKQf15NSfs7JTD0/9fDK/kqe9dH2+4mFxs7lzGkuzZxdu
3dpQXd3nbE9OV6NrbtnSQNc33o7unplpIXB3a+sQ94S5777S/n6X7cNX6I2J
F/bAgXYV22u8ixvPIil0eNkqrMmmTcund8avf33/z352zIMmu+WWgosu+uir
X82+7LJjTjWZhFB5yXKctSJ5HrHs7HMaiPqFUTVCfTj15Lyw1MMn/1t52ku/
58uEkZEw2Sd/f+dp7tzAunXVe/a02dkFoN/u3t1G16GrxVyf7kj3tarmRjQ0
9M+cGQ0o/fDDibe99ODNN6PvUMuWlXH7V669EhLzhqirLAVj7dqqSy458rWv
ZX//+4c9aDK6C1vZ/tGPjjjYZFLh6mqVDI8YFYeeevb5m282OlY2yaB2XLEi
6qg2a1YB9e0CF5GhvVIQMtHi4u4NG2r4UZGYyl++vPz55+syMlpycjrLy3sa
Ggba2oZ6e0eoxuhP+jt9Qp/T/9J36Jv0/fhKnjR2TIbuQvey84xXVJxzr12z
pkrLt9SWlsEbbshla27x4dbVaq/xsL8TLT+dncNsx5NqMje304Mmu/HGvO98
59BPf3p0ypRcurvfFeA8MUISLnnF+P6IVVX1saeD+gGrYvRKQOWl3ptVwtSp
edSr27yaBl2iigwMhPbta09Lq5w+PUHNj5euvjrn8suP//znx+kvCb9AV/v9
70/RlZ0aFwoKurjzyQsvaLi4/fjjp1jpnnuu1uRrYu01YXK8vcaDbqG3LEV6
etPHVlrHPvGgyeiJYB++/bakOnrCxAtJuH1HHx+x556rY19+4okqt4vpMdRj
b95cx9uR+nOnrmzeXlddlUPjFI1W4w1VvneJ6hIKjZ6WpR6PpluzZhWY1yeL
Ck7p//2/o/xD+hX9lq5A13HDL+XQobP8LfWtt7QSpAgEulm5br45P0lXT0vt
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
AAAAACTF/wcE8LKP
"], "Byte", ColorSpace -> "RGB", Interleaving -> True, MetaInformation -> Association["Exif" -> Association["Software" -> "Created with the Wolfram Language : www.wolfram.com"], "Comments" -> Association["Software" -> "Created with the Wolfram Language : www.wolfram.com", "Creation Time" -> DateObject[{2020, 1, 22, 9, 39, 47.}, "Instant", "Gregorian", 0.]]]]//Show[#,ImageSize->270]&//Panel[Column[List[Row[List[Style["Amplituhedron Boundaries",Rule[FontFamily,"Utopia"],Rule[FontSize,24],Rule[FontColor,{0,0,205}//#/256&//RGBColor@@#&//Darker[#,0.1]&]]]],#,Row[List[Style["Tomasz \[CapitalLSlash]ukowski and Robert Moerman (2020)",Rule[FontFamily,"Utopia"],Rule[FontSize,16],Rule[FontColor,{0,0,205}//#/256&//RGBColor@@#&//Darker[#,0.1]&]]]]],Center],Background->({0,0,205}//#/256&//RGBColor@@#&//Lighter[#,0.8]&)]&//Print;
Quiet@Needs["positroids`"];
ClearAll["amplituhedronBoundaries`*"];
ClearAll["amplituhedronBoundaries`Private`*"];


(* ::Input::Initialization:: *)
fetchData::usage="fetchData[] downloads a collection of prepared data files which can be used to instantaneously look-up outputs that have already been computed. The function downloads the tarball Data.tar.gz from https://raw.githubusercontent.com/mrmrob003/amplituhedronBoundaries/master/Data.tar.gz, unzips the tarball and adds any data files to the local data directory Data/ which are not already there; any data files which are already present in Data/ will not be overwritten.";

printCacheStatus::usage="printCacheStatus[] displays the value of the variable $cache. The default value of this variable is False. $cache is a private boolean variable which determines if the output of certain calculations is stored to file or not. The user can choose to have large calculations stored to file by setting the value of $cache to True before loading the package, e.g. 
$cache=True;
<<amplituhedronBoundaries`";

orthComplement::usage="positiveMatrix[nrows,ncolumns] returns a generic (nrows\[Times]ncolumns) matrix with all ordered maximal minors positive, provided nrows\[LessEqual]ncolumns."; 



(* ::Input::Initialization:: *)
posDimension::usage="posDimension[perm] returns the dimension (in the positive Grassmannian) of the positroid cell labelled by the decorated permutation perm as computed by dimension[perm] from positroids.m."; 

topCell::usage="topCell[n,k] returns the decorated permutation labelling the top cell of the positive Grassmannian \!\(\*SubscriptBox[\(G\), \(+\)]\)(k,n)."; 

isTopCellQ::usage="isTopCellQ[perm] returns True if the decorated permutation perm labels the top cell of a positive Grassmanian, and otherwise False.";

posBoundary::usage="posBoundary[perm] returns all co-dimension 1 boundaries (in the positive Grassmannian) of the positroid cell labelled by the decorated permutation perm as computed by boundary[perm] from positroids.m. These boundaries are given by their decorated permutation labels."; 

posBoundaries::usage="posBoundaries[codim,perm] returns all boundaries of co-dimension codim (in the positive Grassmannian) of the positroid cell labelled by the decorated permutation perm. These boundaries are given by their decorated permutation labels."; 

posStratification::usage="posStratification[perm] returns all boundaries in the positroid stratification of the cell labelled by the decorated permutation perm. These boundaries are given by their decorated permutation labels."; 

posStratificationSize::usage="posStratificationSize[perm] returns the total number of boundaries in the positroid stratification of the cell labelled by the decorated permutation perm.";

posInverseBoundary::usage="posInverseBoundary[perm] returns all inverse boundaries (in the positive Grassmannian) of the positroid cell labelled by the decorated permutation perm as computed by inverseBoundary[perm] from positroids.m.";

posInverseBoundaries::usage="posInverseBoundaries[dim,perm] returns all cells of dimension posDimension[perm]+dim (in the positive Grassmannian) which have as one of its boundaries the positroid cell labelled by the decorated permutation perm." ;

posInverseStratification::usage="posInverseStratification[perm] returns all inverse boundaries (in the positive Grassmannian) of the cell labelled by the decorated permutation perm."; (* error code written *)

posInterval::usage="posInterval[perm1,perm2] returns the interval of boundaries in the positive Grassmannian contained between the positroid cells labelled by the decorated permutations perm1 and perm2."; 

posPoset::usage="posPoset[perm] returns the (transitively reduced) adjacency matrix for the poset of all boundaries in the positive Grassmannian of the positroid cell labelled by the decorated permutation perm.

posPoset[perm1,perm2] returns the (transitively reduced) adjacency matrix which for the poset of all boundaries in the interval posInterval[perm1,perm2]." ;

posPermToLeDiagram::usage="posPermToLeDiagram[perm] returns the Le-diagram corresponding to the decorated permutation perm."; 

posLeDiagramToPerm::usage="posLeDiagramToPerm[lediagram] returns the decorated permutation corresponding to the Le-diagram lediagram.";


(* ::Input::Initialization:: *)
ampPermToPatt::usage="Internal function.";
ampPermToTriPatt::usage="Internal function.";

ampDimension::usage="ampDimension[m][perm] returns the dimension of the image (in the amplituhedron) of the positroid cell labelled by the decorated permutation perm.

If the amplituhedron dimension for this positroid cell (and in fact all cells in the positroid stratification of the same positive Grassmannian) is stored to file in the local data directory Data/, then the amplituhedron dimension will be retrieved directly from the file and thereafter stored in the kernel's memory. The first time the amplituhedron dimension is retrieved from the file, a notification message will be displayed.

If the amplituhedron dimension for this positroid cell is not stored to file in Data/, the behaviour of ampDimension depends on the value of $cache.

$cache=False: the amplituhedron dimension of the poistroid cell is calculated directly and thereafter stored in the kernel's memory.
$cache=True: the amplituhedron dimension of all cells in the positroid stratification of the same positive Grassmannian is first calculated, stored in the kernel's memory and stored to file in Data/ before returning the amplituhedron dimension of the positroid cell of interest.

ampDimension[m][perm] can be called using ampDimension[perm,m\[Rule]m'] or simply ampDimension[perm] where the default is m\[Rule]2."; 

ampFaceQ::usage="ampFaceQ[m][perm] returns True if perm labels an amplituhedron face, and otherwise False. We say that perm labels an amplituhedron face if there are no cells in the inverse boundary of perm with the same amplituhedron dimension as perm.

ampFaceQ[m][perm] can be called using ampFaceQ[perm,m\[Rule]m'] or simply ampFaceQ[perm] where the default is m\[Rule]2."; 

ampFaces::usage="ampFaces[m][perm] returns all cells in posStratification[perm] which are amplituhedron faces.

ampFaces}[m][perm] can be called using ampFaces[perm,m\[Rule]m'] or simply ampFaces[perm] where the default is m\[Rule]2."; 

ampBoundaries::usage="ampBoundaries[m,codim][perm] returns all boundaries of co-dimension codim in the amplituhedron of the cell labelled by the decorated permutation perm provided it is either a top cell or a boundary of the top cell in the amplituhedron.

ampBoundaries[m,codim][perm] can be called using ampBoundaries[codim,m\[Rule]m'][perm] or simply ampBoundaries[codim][perm] where the default is m\[Rule]2."; 

ampStratification::usage="ampStratification[m][perm] returns the stratification of all boundaries of the cell labelled by the decorated permutation perm in the amplituhedron provided perm labels either a top cell or a boundary of the top cell in the amplituhedron.

The first-time behaviour of this function depends on whether or not its output already exists on file in Data/. If this is the case, then this output is simply retrieved and stored in the kernel's memory. Otherwise the output is calculated directly and stored in the kernel's memory, and if $cache=True then the output is also then stored to file. A message is displayed the first time the function is executed analogous to the messages displayed by ampDimension detailing its first-time behaviour. 

ampStratification[m][perm] can be called using ampStratification[perm,m\[Rule]m'] or simply ampStratification[perm] where the default is m\[Rule]2.

The following list of functions use \\mmaFuncName{ampStratification} in its computation:
- ampInverseStratification
- ampBoundary
- ampInverseBoundary
- ampInterval
- ampPoset
- ampPermToGraphic
- ampStratificationToHasse
- ampIntervalToHasse
- ampStratificationTo3D
- ampFacetsToGraph
So when calling any of these functions for the first time, one of the above messages generated by ampStratification may be displayed."; 

ampInverseStratification::usage="ampInverseStratification[m][perm] returns the stratification of all inverse boundaries of the cell labelled by the decorated permutation perm in the amplituhedron provided perm labels a boundary in the amplituhedron. 

ampInverseStratification[m][perm] can be called using ampInverseStratification[perm,m\[Rule]m'] or simply ampInverseStratification[perm] where the default is m\[Rule]2.";

ampBoundary::usage="ampBoundary[m][perm] returns all co-dimension 1 boundaries (in the amplituhedron) of the cell labelled by the decorated permutation perm provided perm labels a boundary in the amplituhedron.

Currently ampBoundary is only implemented for m=2.

ampBoundary[2][perm] can be called using ampBoundary[perm,m\[Rule]2] or simply ampBoundary[perm] where the default is m\[Rule]2.";

ampInverseBoundary::usage="ampInverseBoundary[m][perm] returns all inverse boundaries (in the amplituhedron) with amplituhedron dimension ampDimension[m][perm]+1 of the cell labelled by the decorated permutation perm provided perm labels a boundary in the amplituhedron.

Currently ampInverseBoundary is only implemented for m=2.

ampInverseBoundary[2,perm] can be called using ampInverseBoundary[perm,m\[Rule]2] or simply ampInverseBoundary[perm] where the default is m\[Rule]2."; 

ampInterval::usage="ampInterval[m][perm1,perm2] returns the interval of boundaries in the amplituhedron contained between the cells labelled by the decorated permutations perm1 and perm2.

Currently ampInterval is only implemented for m=2.

ampInterval[2][perm1,perm2] can be called using ampInterval[perm1,perm2,m\[Rule]2] or simply ampInterval[perm1,perm2] where the default is m\[Rule]2.";

ampPoset::usage="ampPoset[m][perm] returns the (transitively reduced) adjacency matrix which defines the poset structure induced by inclusion for all boundaries (in the amplituhedron) of the cell labelled by the decorated permutation perm.

Currently ampPoset is only implemented for m=2.

ampPoset[2][perm] can be called using ampPoset[perm,m\[Rule]2] or simply ampPoset[perm] where the default is m\[Rule]2.

ampPoset[m][perm1,perm2] returns the (transitively reduced) adjacency matrix which defines the poset structure induced by inclusion for all boundaries in the interval ampInterval[m][perm1,perm2].

Currently ampPoset is only implemented for m=2.

ampPoset[2][perm1,perm2] can be called using ampPoset[perm1,perm2,m\[Rule]2] or simply ampPoset[perm1,perm2] where the default is m\[Rule]2.";

ampGeneralizedTriangles::usage="ampGeneralizedTriangles[m][n,k] returns all generalized triangles in the amplituhedron.

The first-time behaviour of this function depends on whether or not its output already exists on file in Data/. If this is the case, then this output is simply retrieved and stored in the kernel's memory. Otherwise the output is calculated directly and stored in the kernel's memory, and if $cache=True then the output is also then stored to file. A message is displayed the first time the function is executed analogous to the messages displayed by ampDimension detailing its first-time behaviour. 

Currently ampGeneralizedTriangles is only implemented for m=2.

ampGeneralizedTriangles[m][n,k] can be called using ampGeneralizedTriangles[n,k,m\[Rule]m'] or simply ampGeneralizedTriangles[n,k] where the default is m\[Rule]2."; 

ampPermToGraphic::usage="ampPermToGraphic[m][perm] returns the compact graphical label for the cell in the amplituhedron corresponding to the decorated permutation perm.

Currently ampPermToGraphic is only implemented for m=2. These compact graphical labels for are defined in [arXiv:1908.00386]: they consist of lines and points inside an n-gon (where n=Length[perm]).

ampPermToGraphic[2][perm] can be called using ampPermToGraphic[perm,m\[Rule]2] or simply ampPermToGraphic[perm] where the default is m\[Rule]2.

ampPermToGraphic additionally admits the following optional parameters:
\[FilledSquare] showLabels (default True):
  showLabels\[RightArrow]True \[DoubleRightArrow] displays the labels of the vertices of the n-gon
  showLabels\[RightArrow]False \[DoubleRightArrow] leaves the labels of the vertices of the n-gon off
\[FilledSquare] noLabelsResize (default False):
  noLabelsResize\[Rule]True \[DoubleRightArrow] resizes the n-gon if labels are not shown
  noLabelsResize\[Rule]False \[DoubleRightArrow] the n-gon is not resized if labels are not shown
\[FilledSquare] imageSize (default 80): the image size can be set arbitrarily, but defaults to 80";

ampStratificationToHasse::usage="ampStratificationToHasse[m][perm] returns a Hasse diagram for the poset of boundaries in ampStratification[m][perm].

Currently ampStratificationToHasse is only implemented for m=2.

ampStratificationToHasse[2][perm] can be called using ampStratificationToHasse[perm,m\[Rule]2] or simply ampStratificationToHasse[perm] where the default is m\[Rule]2.

ampStratificationToHasse additionally admits the following optional parameters:
\[FilledSquare] showGraphics (default True):
  showGraphics\[Rule]True \[Implies] displays graphical labels generated by ampPermToGraphic in the nodes of the Hasse diagram
  showGraphics\[Rule]False \[Implies] leaves the nodes of the Hasse diagram empty
\[FilledSquare] showLabels (default True):
  showLabels\[Rule]True \[Implies] displays the labels of the vertices of the n-gon in the graphic generated by ampPermToGraphic
  showLabels\[Rule]False \[Implies] leaves the labels of the vertices of the n-gon in the graphic generated by ampPermToGraphic off
\[FilledSquare] showPermutations (default True):
  showPermutations\[Rule]True \[Implies] displays permutation labels above the nodes of the Hasse diagram
  showPermutations\[Rule]False \[Implies] leaves permutation labels above the nodes of the Hasse diagram off
\[FilledSquare] rasterize (default True):
  rasterize\[Rule]True \[Implies] rasterizes the Hasse diagram so that is can be easily resized
  rasterize\[Rule]False \[Implies] does not rasterize the Hasse diagram
\[FilledSquare] imageResolution (default Automatic): the resolution of the rasterized Hasse diagram can be set arbitrarily, but defaults to Automatic
\[FilledSquare] edgeScale (default 1): the edge thickness can be scaled arbitrarily, but defaults to 1"; 

ampStratificationToTable::usage="ampStratificationToTable[m][perm] returns a table of the cells in ampStratification[m][perm] organised with respect to their amplituhedron dimensions.

Currently ampStratificationToTable is only implemented for m=2.

ampStratificationToTable[2][perm] can be called using ampStratificationToTable[perm,m\[Rule]2] or simply ampStratificationToTable[perm] where the default is m\[Rule]2.

ampStratificationToTable additionally admits the following optional parameters:
\[FilledSquare] showLabels (default True):
  showLabels\[Rule]True \[Implies] displays the labels of the vertices of the n-gon in the graphic generated by ampPermToGraphic
  showLabels\[Rule]False \[Implies] leaves the labels of the vertices of the n-gon in the graphic generated by ampPermToGraphic off
\[FilledSquare] showPermutations (default True):
  showPermutations\[Rule]True \[Implies] displays permutation labels above the nodes of the Hasse diagram
  showPermutations\[Rule]False \[Implies] leaves permutation labels above the nodes of the Hasse diagram off
\[FilledSquare] fancePermutations (default False):
  fancyPermutations\[Rule]True \[Implies] displays permutation labels in LaTeX font
  fancyPermutations\[Rule]False \[Implies] leaves permutation labels unformatted
\[FilledSquare] graphicType (default \"polygon\"):
  graphicType\[Rule]\"polygon\" \[Implies] displays the graphic generated by ampPermToGraphic for each boundary
  graphicType\[Rule]\"lediagram\" \[Implies] displays the \\Le-diagram generated by {\\tt posPermToLeDiagram} for each boundary";

ampIntervalToHasse::usage="ampIntervalToHasse[m][perm1,perm2] returns a Hasse diagram for the poset of boundaries in ampInterval[m][perm1,perm2].

Currently ampIntervalToHasse is only implemented for m=2.

ampIntervalToHasse[2][perm1,perm2] can be called using ampIntervalToHasse[perm1,perm2,m\[Rule]2] or simply ampIntervalToHasse[perm1,perm2] where the default is m\[Rule]2.
ampIntervalToHasse additionally admits the same optional parameters as ampStratificationToHasse."; 

ampStratificationTo3D::usage="ampStratificationTo3D[m][perm] returns a graph of connections between zero-dimensional cells in ampStratification[m][perm] provided the cell in the amplituhedron labelled by the decorated permutation perm has amplituhedron dimension less than or equal to 3.

Currently ampStratificationTo3D is only implemented for m=2.

ampStratificationTo3D[2][perm] can be called using ampStratificationTo3D[perm,m\[Rule]2] or simply ampStratificationTo3D[perm] where the default is m\[Rule]2.

ampStratificationTo3D additionally admits the following optional parameters:
\[FilledSquare] showGraphics (default True):
  showGraphics\[Rule]True \[Implies] displays graphical labels generated by ampPermToGraphic for each vertex in the graph
  showGraphics\[Rule]False \[Implies] does not display graphical labels
\[FilledSquare] showLabels (default True):
  showLabels\[Rule]True \[Implies] displays the labels of the vertices of the n-gon in the graphic generated by ampPermToGraphic
  showLabels\[Rule]False \[Implies] leaves the labels of the vertices of the n-gon in the graphic generated by ampPermToGraphic off
\[FilledSquare] showPermutations (default True):
  showPermutations\[Rule]True \[Implies] displays permutation labels for each vertex in the graph
  showPermutations\[Rule]False \[Implies] does not display permutation labels
\[FilledSquare] imageSize (default 40): the image size of the graphic generated by ampPermToGraphic can be set arbitrarily, but defaults to 40"; 

ampFacetsToGraph::usage="ampFacetsToGraph[m][perm] returns a star-shaped graph of the facets (co-dimension 1 boundaries) of the cell in the amplituhedron labelled by the decorated permutation perm provided it is an element of the boundary stratification of the amplituhedron and it has amplituhedron dimension greater than or equal to 1.

Currently ampFacetsToGraph is only implemented for m=2.

ampFacetsToGraph[2][perm] can be called using ampFacetsToGraph[perm,m\[Rule]2] or simply ampFacetsToGraph[perm] where the default is m\[Rule]2.
ampFacetsToGraph additionally admits the same optional parameters as ampStratificationToHasse."; (* error code written *)



(* ::Input::Initialization:: *)
momDimension::usage="see ?ampDimension."; 

momFaceQ::usage="see ?ampFaceQ."; 

momFaces::usage="see ?ampFaces."; 

momBoundaries::usage="see ?ampBoundaries.";

momStratification::usage="see ?ampStratification.";

momInverseStratification::usage="see ?ampInverseStratification."; 

momBoundary::usage="see ?ampBoundary."; 

momInverseBoundary::usage="see ?ampInverseBoundary."; 

momInterval::usage="see ?ampInterval."; 

momPoset::usage="see ?ampPoset."; 

momStratificationToHasse::usage="momStratificationToHasse[m][perm] returns a Hasse diagram for the poset of boundaries in momStratification[m][perm].

momStratificationToHasse[m][perm] can be called using momStratificationToHasse[perm,m\[Rule]m'] or simply momStratificationToHasse[perm] where the default is m\[Rule]2.

momStratificationToHasse additionally admits the following optional parameters:
\[FilledSquare] showGraphics (default True):
  showGraphics\[Rule]True \[Implies] displays Le-diagrams in the nodes of the Hasse diagram
  showGraphics\[Rule]False \[Implies] leaves the nodes of the Hasse diagram empty
\[FilledSquare] showPermutations (default True):
  showPermutations\[Rule]True \[Implies] displays permutation labels above the nodes of the Hasse diagram
  showPermutations\[Rule]False \[Implies] leaves permutation labels above the nodes of the Hasse diagram off
\[FilledSquare] rasterize (default True):
  rasterize\[Rule]True \[Implies] rasterizes the Hasse diagram so that is can be easily resized
  rasterize\[Rule]False \[Implies] does not rasterize the Hasse diagram
\[FilledSquare] imageResolution (default Automatic): the resolution of the rasterized Hasse diagram can be set arbitrarily, but defaults to Automatic
\[FilledSquare] edgeScale (default 1): the edge thickness can be scaled arbitrarily, but defaults to 1";

momStratificationToTable::usage="momStratificationToTable[m][perm] returns a table of the cells in momStratification[m][perm] organised with respect to their momentum amplituhedron dimensions.

momStratificationToTable[m][perm] can be called using momStratificationToTable[perm,m\[Rule]m'] or simply momStratificationToTable[perm] where the default is m\[Rule]2.

momStratificationToTable additionally admits the following optional parameters:
\[FilledSquare] showPermutations (default True):
  showPermutations\[Rule]True \[Implies] displays permutation labels above the nodes of the Hasse diagram
  showPermutations\[Rule]False \[Implies] leaves permutation labels above the nodes of the Hasse diagram off
\[FilledSquare] fancePermutations (default False):
  fancyPermutations\[Rule]True \[Implies] displays permutation labels in LaTeX font
  fancyPermutations\[Rule]False \[Implies] leaves permutation labels unformatted";

momIntervalToHasse::usage="momIntervalToHasse[m][perm1,perm2] returns a Hasse diagram for the poset of boundaries in momInterval[m][perm1,perm2].

momIntervalToHasse[m][perm1,perm2] can be called using momIntervalToHasse[perm1,perm2,m\[Rule]m'] or simply momIntervalToHasse[perm1,perm2] where the default is m\[Rule]2.
momIntervalToHasse additionally admits the same optional parameters as momStratificationToHasse.";

momStratificationTo3D::usage="momStratificationTo3D[m][perm] returns a graph depicting the combinatorial relation between zero-dimensional boundaries in momStratification[m][perm] provided the cell in the momentum amplituhedron labelled by the decorated permutation perm has amplituhedron dimension less than or equal to 3.

momStratificationTo3D[m][perm] can be called using momStratificationTo3D[perm,m\[Rule]m'] or simply momStratificationTo3D[perm] where the default is m\[Rule]2.

momStratificationTo3D additionally admits the following optional parameters:
\[FilledSquare] showGraphics (default True):
  showGraphics\[Rule]True \[Implies] displays Le-diagrams for each vertex in the graph
  showGraphics\[Rule]False \[Implies] does not display Le-diagrams
\[FilledSquare] showPermutations (default True):
  showPermutations\[Rule]True \[Implies] displays permutation labels for each vertex in the graph
  showPermutations\[Rule]False \[Implies] does not display permutation labels"; 

momFacetsToGraph::usage="momFacetsToGraph[m][perm] returns a star-shaped graph of the facets (co-dimension 1 boundaries) of the cell in the momentum amplituhedron labelled by the decorated permutation perm provided it has momentum amplituhedron dimension greater than or equal to 1.

momFacetsToGraph[m][perm] can be called using momFacetsToGraph[perm,m\[Rule]m'] or simply momFacetsToGraph[perm] where the default is m\[Rule]2.
momFacetsToGraph additionally admits the same optional parameters as momStratificationToHasse."; 



(* ::Input::Initialization:: *)
hypDimension::usage="see ?ampDimension.";

hypBasis::usage="hypBasis[perm] returns a list of all k-length subsets of [n]={1,...,n} (where k=permK[perm] and n=Length[perm]) which label the non-zero ordered maximal k\[Times]k minors of permToMat[perm].";

hypBases::usage="hypBases[n,k] returns the output hypBasis evaluated for all cells in the positroid stratification of the positive Grassmannian \!\(\*SubscriptBox[\(G\), \(+\)]\)(k,n).";

hypFaceQ::usage="see ?ampFaceQ.";

hypFaces::usage="see ?ampFaces.";

hypBoundaries::usage="see ?ampBoundaries.";

hypStratification::usage="see ?ampStratification.";

hypInverseStratification::usage="see ?ampInverseStratification.";

hypBoundary::usage="see ?ampBoundary.";

hypInverseBoundary::usage="see ?ampInverseBoundary.";

hypInterval::usage="see ?ampInterval.";

hypPoset::usage="see ?ampPoset.";

hypStratificationToHasse::usage="see ?ampBoundary.";

hypStratificationToTable::usage="see ?momStratificationToTable.";

hypIntervalToHasse::usage="see ?momIntervalToHasse.";

hypStratificationTo3D::usage="see ?momStratificationTo3D.";

hypFacetsToGraph::usage="see ?momFacetsToGraph.";


Begin["`Private`"];
Needs["MaTeX`"];


(* ::Input::Initialization:: *)
$cachePrivate=Global`$cache//If[BooleanQ[#],#,False]&;
printCacheStatus[]:=$cachePrivate


(* ::Input::Initialization:: *)
ampDefaults["m"]=2;
momDefaults["m"]=2;


(* ::Input::Initialization:: *)
displayProgress[frac_/;NumberQ[frac]]:=Grid[{{ProgressIndicator[Dynamic[frac]],Dynamic[Round[N[100 frac]]],"%"}}]


(* ::Input::Initialization:: *)
messages["first"]["general"][args___]:=List@args//Table[ToString[#[[A1]]]<>"="<>"`"<>ToString[A1]<>"`",{A1,#//Length}]&//Riffle[#,", "]&//StringJoin@@#&//"called for the first time with "<>#<>"; "&
messages["first"]["save"][args___]:=messages["first"]["general"][args]<>"constructing and saving definition to \"`"<>ToString[Length[List[args]]+1]<>"`\".";
messages["first"]["fly"][args___]:=messages["first"]["general"][args]<>"calculating definition on-the-fly.";
messages["first"]["load"][args___]:=messages["first"]["general"][args]<>"loading definition from \"`"<>ToString[Length[List[args]]+1]<>"`\".";

messages["badargs"]["general"]="invalid argument - ";
messages["badargs"]["perm"][bracket_:0,position_:0]:=messages["badargs"]["general"]<>"affine permutation expected"<>If[bracket>0," in bracket "<>ToString[bracket],""]<>If[position>0," at position "<>ToString[position],""]<>".";
messages["badargs"]["patt"][bracket_:0,position_:0]:=messages["badargs"]["general"]<>"legal pattern expected"<>If[bracket>0," in bracket "<>ToString[bracket],""]<>If[position>0," at position "<>ToString[position],""]<>".";
messages["badargs"]["cell"][geometry_,bracket_:0,position_:0]:=messages["badargs"]["general"]<>"affine permutation"<>If[bracket>0," in bracket "<>ToString[bracket],""]<>If[position>0," at position "<>ToString[position],""]<>" is not a boundary of "<>ToString[geometry]<>".";
messages["badargs"][variable_/;Not[StringQ[variable]],type_][bracket_:0,position_:0]:=messages["badargs"]["general"]<>"variable \""<>ToString[variable]<>"\""<>If[bracket>0," in bracket "<>ToString[bracket],""]<>If[position>0," at position "<>ToString[position],""]<>" needs to be "<>ToString[type]<>".";
messages["badargs"]["bound"][condition_]:=messages["badargs"]["general"]<>"function requires "<>ToString[condition]<>".";
messages["badargs"]["implemented"][condition_]:=messages["badargs"]["general"]<>"function only implemented for "<>ToString[condition]<>".";


(* ::Input::Initialization:: *)
isZeroQ[x_]:=x//Simplify//FreeQ[#,Global`\[Alpha]]&&#==0&


(* ::Input::Initialization:: *)
positiveMatrix[nrows_/;(IntegerQ[nrows]&&nrows>0),ncolumns_/;(IntegerQ[ncolumns]&&ncolumns>0)]/;nrows<=ncolumns:=(positiveMatrix[nrows,ncolumns]=Table[A2^A1,{A1,nrows},{A2,ncolumns}])

positiveMatrix::badargsNrows=messages["badargs"][nrows,"a positive integer"][0,1];
positiveMatrix::badargsNcolumns=messages["badargs"][ncolumns,"a positive integer"][0,2];
positiveMatrix::badargsBound=messages["badargs"]["bound"]["nrows\[LessEqual]ncolumns"];
positiveMatrix[nrows_,ncolumns_]:=(Message[positiveMatrix::badargsNrows];$Failed)/;Not[IntegerQ[nrows]&&nrows>0]
positiveMatrix[nrows_,ncolumns_]:=(Message[positiveMatrix::badargsNcolumns];$Failed)/;Not[IntegerQ[ncolumns]&&ncolumns>0]
positiveMatrix[nrows_,ncolumns_]:=(Message[positiveMatrix::badargsBound];$Failed)/;Not[nrows<=ncolumns]


(* ::Input::Initialization:: *)
orthComplement[matrix_/;MatrixQ[matrix]&&Length[matrix]<=Length[matrix[[1]]]&&MatrixRank[matrix]==Length[matrix]]:=Block[{nrows=Length[matrix],ncolumns=Length[matrix[[1]]],colMaxRank,colOther,mat},colMaxRank=ncolumns//Range//Subsets[#,{nrows}]&//Select[#,!isZeroQ[Det[matrix[[;;,#]]]]&]&//#[[1]]&;
colOther=Complement[Range[ncolumns],colMaxRank];
mat=Inverse[Transpose[Transpose[matrix][[colMaxRank]]]].matrix//Expand;
mat=Transpose[Transpose[mat][[colOther]]];
Transpose[Table[If[MemberQ[colMaxRank,i],-mat[[Position[colMaxRank,i][[1,1]]]],IdentityMatrix[Length[colOther]][[Position[colOther,i][[1,1]]]]],{i,1,ncolumns}]]]

orthComplement::badargsMatrix=messages["badargs"][matrix,"a matrix"][0,0];
orthComplement::badargsBound=messages["badargs"]["bound"]["rows of matrix\[LessEqual]columns of matrix"];
orthComplement::badargsRank=messages["badargs"]["bound"]["matrix to be of maximal rank"];
orthComplement[matrix_]:=(Message[orthComplement::badargsMatrix];$Failed)/;Not[MatrixQ[matrix]]
orthComplement[matrix_]:=(Message[orthComplement::badargsBound];$Failed)/;Not[Length[matrix]<=Length[matrix[[1]]]]
orthComplement[matrix_]:=(Message[orthComplement::badargsRank];$Failed)/;Not[MatrixRank[matrix]==Length[matrix]]


(* ::Input::Initialization:: *)
ClearAll[dataDirectory,dataFilename,dataLoad,dataSave]
dataDirectory=FileNameJoin[{NotebookDirectory[],"Data"}];
dataDirectory::first="created the following local directory for storing data: `1`.";
If[($cachePrivate)&&(!FileExistsQ[dataDirectory]),Message[dataDirectory::first,dataDirectory];CreateDirectory[dataDirectory]]

dataFilename[functionName_,args___]:=Join[{ToString[functionName]},List[args]//ToString[#]&/@#&]//Riffle[#,"-"]&//StringJoin@@#&//(StringJoin@@{#,".m"})&//FileNameJoin[{dataDirectory,#}]&

dataLoad[functionName_,args___]:=Block[{contents=Get[dataFilename[functionName,args]]},
If[Length[contents[[1,1]]]>1,contents//(functionName[Sequence@@#[[1,2;;]]][#[[1,1]]]=#[[2]])&/@#&,contents//(functionName[#[[1,1]]]=#[[2]])&/@#&]]

dataSave[functionName_,args___][data_]:=Block[{filename=dataFilename[functionName,args]},Put[data,filename]]/;!FileExistsQ[dataFilename[functionName,args]];


(* ::Input::Initialization:: *)
fetchData::pass="Data successfully fetched.";
fetchData::fail="Data unsuccessfully fetched.";
fetchData::unzip="Unable to unzip tarball.";
fetchData::download="Unable to download tarball from GitHub.";
fetchData[]:=Module[{filename="Data.tar.gz",connection,tmpDir=CreateDirectory[],unzippedFiles,currentFiles,movedFiles},
Quiet[connection=
URLDownload["https://raw.githubusercontent.com/mrmrob003/amplituhedronBoundaries/master/"<>filename,FileNameJoin[{tmpDir,filename}]]];
If[connection===$Failed||!FileExistsQ[connection],
Message[fetchData::download];
Message[fetchData::fail];,
If[ExtractArchive[connection,tmpDir]===$Failed,
Message[fetchData::unzip];
Message[fetchData::fail];
,
FileNameJoin[{tmpDir,"Data","PaxHeader"}]//If[FileExistsQ[#],DeleteDirectory[#,DeleteContents->True]]&;
unzippedFiles=FileNameTake/@FileNames[All,FileNameJoin[{tmpDir,"Data"}]];
currentFiles=FileNameTake/@FileNames[All,dataDirectory];
movedFiles=Complement[unzippedFiles,currentFiles];
If[Length[movedFiles]>0,
CopyFile[FileNameJoin[{tmpDir,"Data",#}],FileNameJoin[{dataDirectory,#}]]&/@movedFiles;
Print["The following files were added to "<>dataDirectory<>":"];
Print["- "<>#]&/@movedFiles;
,Print["No new files were added to "<>dataDirectory<>"."];
];
tmpDir//If[FileExistsQ[#],DeleteDirectory[#,DeleteContents->True]]&;
Message[fetchData::pass];
]
]
]


(* ::Input::Initialization:: *)
ClearAll[legalListPermQ]
legalListPermQ[perm_]:=(legalListPermQ[perm]=True)/;(ListQ[perm]&&Global`legalPermQ[perm])
legalListPermQ[___]:=False


permK[perm_]:=Global`permK[perm]
permToMat[perm_]:=Global`permToMat[perm]
matToPerm[perm_]:=Global`matToPerm[perm]


(* ::Input::Initialization:: *)
posDimension[perm_/;legalListPermQ[perm]]:=posDimension[perm]=Global`dimension[perm]

posDimension::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
posDimension[perm_]:=(Message[posDimension::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]


(* ::Input::Initialization:: *)
topCell[n_/;IntegerQ[n]&&n>0,k_/;IntegerQ[k]&&k>=0]:=(topCell[n,k]=Range[n]+k)/;(k<=n)

topCell::badargsN=messages["badargs"][n,"a positive integer"][0,1];
topCell::badargsK=messages["badargs"][k,"a non-negative integer"][0,2];
topCell::badargsBound=messages["badargs"]["bound"]["k\[LessEqual]n"];
topCell[n_,k_]:=(Message[topCell::badargsN];$Failed)/;Not[IntegerQ[n]&&n>0]
topCell[n_,k_]:=(Message[topCell::badargsK];$Failed)/;Not[IntegerQ[k]&&k>=0]
topCell[n_,k_]:=(Message[topCell::badargsBound];$Failed)/;Not[k<=n]

isTopCellQ[perm_]:=isTopCellQ[perm]=legalListPermQ[perm]&&(posDimension[perm]==permK[perm](Length[perm]-permK[perm]))


(* ::Input::Initialization:: *)
posBoundary[perm_/;legalListPermQ[perm]]:=(posBoundary[perm]=Global`boundary[perm]);

posBoundary::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
posBoundary[perm_]:=(Message[posBoundary::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]

posBoundaries[0][perm_/;legalListPermQ[perm]]:=(posBoundaries[0][perm]={perm})
posBoundaries[codim_/;(IntegerQ[codim]&&codim>0)][perm_/;legalListPermQ[perm]]:=(posBoundaries[codim][perm]=(posBoundaries[codim-1][perm]//posBoundary/@#&//Flatten[#,1]&//Union))

posBoundaries::badargsCodim=messages["badargs"][codim,"a non-negative integer"][1,0];
posBoundaries::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
posBoundaries[codim_][perm_]:=(Message[posBoundaries::badargsCodim];$Failed)/;Not[IntegerQ[codim]&&codim>=0]
posBoundaries[codim_][perm_]:=(Message[posBoundaries::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]

posStratification[perm_/;legalListPermQ[perm]]:=posStratification[perm]=Table[posBoundaries[A1][perm],{A1,0,posDimension[perm]}]//Flatten[#,1]&

posStratification::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
posStratification[perm_]:=(Message[posStratification::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]

posStratificationSize[perm_/;legalListPermQ[perm]]:=posStratificationSize[perm]=posStratification[perm]//Length

posStratificationSize::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
posStratificationSize[perm_]:=(Message[posStratificationSize::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]


(* ::Input::Initialization:: *)
posInverseBoundary[perm_/;legalListPermQ[perm]]:=(posInverseBoundary[perm]=Global`inverseBoundary[perm])

posInverseBoundary::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
posInverseBoundary[perm_]:=(Message[posInverseBoundary::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]

posInverseBoundaries[0][perm_/;legalListPermQ[perm]]:=(posInverseBoundaries[0][perm]={perm})
posInverseBoundaries[dim_/;IntegerQ[dim]&&0<dim][perm_/;legalListPermQ[perm]]:=(posInverseBoundaries[dim][perm]=(posInverseBoundaries[dim-1][perm]//posInverseBoundary/@#&//Flatten[#,1]&//Union))/;(posDimension[perm]+dim<=permK[perm](Length[perm]-permK[perm]))

posInverseBoundaries::badargsDim=messages["badargs"][dim,"a non-negative integer"][1,0];
posInverseBoundaries::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
posInverseBoundaries[dim_][perm_]:=(Message[posInverseBoundaries::badargsCodim];$Failed)/;Not[IntegerQ[dim]&&dim>=0]
posInverseBoundaries[dim_][perm_]:=(Message[posInverseBoundaries::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]

posInverseStratification[perm_/;legalListPermQ[perm]]:=posInverseStratification[perm]=
Table[posInverseBoundaries[A1][perm],{A1,0,permK[perm](Length[perm]-permK[perm])-posDimension[perm]}]//Reverse//Flatten[#,1]&

posInverseStratification::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
posInverseStratification[perm_]:=(Message[posInverseStratification::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]


(* ::Input::Initialization:: *)
posInterval[perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2]]:=(posInterval[perm1,perm2]=If[perm1==perm2,{perm1},{}])/;(Length[perm1]==Length[perm2]&&permK[perm1]==permK[perm2]&&posDimension[perm1]==posDimension[perm2])

posInterval[perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2]]:=(posInterval[perm1,perm2]=
Intersection[posStratification[perm1],posInverseStratification[perm2]]
)/;(Length[perm1]==Length[perm2]&&permK[perm1]==permK[perm2]&&posDimension[perm1]>posDimension[perm2])

posInterval[perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2]]:=(posInterval[perm1,perm2]=posInterval[perm2,perm1]
)/;(Length[perm1]==Length[perm2]&&permK[perm1]==permK[perm2]&&posDimension[perm1]<posDimension[perm2])

posInterval::badargsPerm1=messages["badargs"][perm1,"an affine permutation"][0,1];
posInterval::badargsPerm2=messages["badargs"][perm2,"an affine permutation"][0,2];
posInterval::badargsLength=messages["badargs"]["bound"]["Length[perm1]\[Equal]Length[perm2]"];
posInterval::badargsPermK=messages["badargs"]["bound"]["permK[perm1]\[Equal]permK[perm2]"];
posInterval[perm1_,perm2_]:=(Message[posInterval::badargsPerm1];$Failed)/;Not[legalListPermQ[perm1]]
posInterval[perm1_,perm2_]:=(Message[posInterval::badargsPerm2];$Failed)/;Not[legalListPermQ[perm2]]
posInterval[perm1_,perm2_]:=(Message[posInterval::badargsLength];$Failed)/;Not[Length[perm1]==Length[perm2]]
posInterval[perm1_,perm2_]:=(Message[posInterval::badargsPermK];$Failed)/;Not[permK[perm1]==permK[perm2]]

posPoset[perm_/;isTopCellQ[perm]]:=posPoset[perm]=perm//posStratification//Table[MemberQ[posStratification[#[[A1]]],#[[A2]]],{A1,#//Length},{A2,#//Length}]&//Boole//AdjacencyGraph//TransitiveReductionGraph//AdjacencyMatrix

posPoset[perm_/;legalListPermQ[perm]]:=posPoset[perm]=Block[{n=Length[perm],k=permK[perm],indices},
indices=perm//posStratification//Position[topCell[n,k]//posStratification,#]&/@#&//Flatten;
topCell[n,k]//posPoset//#[[indices,indices]]&
]

posPoset::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
posPoset[perm_]:=(Message[posPoset::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]

posPoset[perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2]]:=(posPoset[perm1,perm2]=Block[{n=Length[perm1],k=permK[perm1],indices},
indices=posInterval[perm1,perm2]//Position[topCell[n,k]//posStratification,#]&/@#&//Flatten;
topCell[n,k]//posPoset//#[[indices,indices]]&
])/;(Length[perm1]==Length[perm2]&&permK[perm1]==permK[perm2])

posPoset::badargsPerm1=messages["badargs"][perm1,"an affine permutation"][0,1];
posPoset::badargsPerm2=messages["badargs"][perm2,"an affine permutation"][0,2];
posPoset::badargsLength=messages["badargs"]["bound"]["Length[perm1]\[Equal]Length[perm2]"];
posPoset::badargsPermK=messages["badargs"]["bound"]["permK[perm1]\[Equal]permK[perm2]"];
posPoset[perm1_,perm2_]:=(Message[posPoset::badargsPerm1];$Failed)/;Not[legalListPermQ[perm1]]
posPoset[perm1_,perm2_]:=(Message[posPoset::badargsPerm2];$Failed)/;Not[legalListPermQ[perm2]]
posPoset[perm1_,perm2_]:=(Message[posPoset::badargsLength];$Failed)/;Not[Length[perm1]==Length[perm2]]
posPoset[perm1_,perm2_]:=(Message[posPoset::badargsPermK];$Failed)/;Not[permK[perm1]==permK[perm2]]


(* ::Input::Initialization:: *)
ampMap[m_/;IntegerQ[m]&&m>0][perm_/;legalListPermQ[perm]]:=(ampMap[m][perm]=permToMat[perm].Transpose@positiveMatrix[permK[perm]+m,Length[perm]])/;(permK[perm]+m<=Length[perm])
ampMap[perm_/;legalListPermQ[perm],OptionsPattern[{m->ampDefaults["m"]}]]:=ampMap[OptionValue[m]][perm]

ampMap::badargsM=messages["badargs"][m,"a positive integer"][1,0];
ampMap::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampMap::badargsBound=messages["badargs"]["bound"]["permK[perm]+m\[LessEqual]Length[perm]"];
ampMap[m_][perm_]:=(Message[ampMap::badargsM];$Failed)/;Not[IntegerQ[m]&&m>0]
ampMap[m_][perm_]:=(Message[ampMap::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampMap[m_][perm_]:=(Message[ampMap::badargsBound];$Failed)/;Not[permK[perm]+m<=Length[perm]]


(* ::Input::Initialization:: *)
(* hard code top cell and zero cells *)
ampDimensionv1[m_/;IntegerQ[m]&&m>0][perm_/;isTopCellQ[perm]]:=(ampDimension[m][perm]=m permK[perm])
ampDimensionv1[m_/;IntegerQ[m]&&m>0][perm_/;legalListPermQ[perm]&&(posDimension[perm]==0)]:=(ampDimension[m][perm]=0)
(* only calculate for single representative from each cyclicRep equivalence class *)
ampDimensionv1[m_/;IntegerQ[m]&&m>0][perm_/;legalListPermQ[perm]&&perm==Global`cyclicRep[perm]]:=(ampDimension[m][perm]=Block[{cmat=permToMat[perm],k=permK[perm],g,glTransformation,dim},
glTransformation=Table[Subscript[g, A1,A2],{A1,k},{A2,k}];
dim=glTransformation.ampMap[m][perm]//Flatten//Table[D[#,A1],{A1,Join[Table[Global`\[Alpha][A1],{A1,posDimension[perm]}],glTransformation]//Flatten}]&//MatrixRank//#-k^2&;
ampDimensionv1[m][perm]=dim;
dim
])/;(permK[perm]+m<=Length[perm])
ampDimensionv1[m_/;IntegerQ[m]&&m>0][perm_/;legalListPermQ[perm]]:=(ampDimension[m][perm]=ampDimensionv1[m][Global`cyclicRep[perm]])

ampDimensionv2[m_/;IntegerQ[m]&&m>0][perm_/;isTopCellQ[perm]]:=(ampDimension[m][perm]=m permK[perm])
ampDimensionv2[m_/;IntegerQ[m]&&m>0][perm_/;legalListPermQ[perm]&&posDimension[perm]==0]:=(ampDimension[m][perm]=0)
ampDimensionv2[m_/;IntegerQ[m]&&m>0][perm_/;legalListPermQ[perm]&&perm==Global`cyclicRep[perm]]:=(ampDimension[m][perm]=Block[{k=permK[perm],n=Length[perm],Ymat,gauge,denom,coords,dim},
Ymat=permToMat[perm].Transpose@positiveMatrix[k+m,n];
gauge=Subsets[Range[k+m],{k}]//Select[#,!isZeroQ[Det[Ymat[[;;,#]]]]&]&//#[[1]]&;
denom=Ymat[[;;,gauge]]//Det;
coords=Subsets[Range[k+m],{k}]//Select[#,Length[Intersection[gauge,#]]==k-1&]&//Ymat[[;;,#]]&/@#&//Det/@#&;
dim=coords//#/denom&/@#&//Table[D[#,A1],{A1,Table[Global`\[Alpha][A1],{A1,posDimension[perm]}]}]&//MatrixRank;
ampDimensionv2[m][perm]=dim;
dim
])/;(permK[perm]+m<=Length[perm])
ampDimensionv2[m_/;IntegerQ[m]&&m>0][perm_/;legalListPermQ[perm]]:=(ampDimension[m][perm]=ampDimensionv2[m][Global`cyclicRep[perm]])

Options[ampDimension]={m->ampDefaults["m"],version->1};
Options[defineAmpDimension]=Options[ampDimension];

defineAmpDimension[m_,options:OptionsPattern[]][n_,k_]:=Block[{filename=dataFilename[ampDimension,n,k,m],dimFunc,depth,calc},
If[!FileExistsQ[filename],
dimFunc=If[OptionValue[version]==2,ampDimensionv2[m],ampDimensionv1[m]];
depth=posStratificationSize[topCell[n,k]];Monitor[calc=topCell[n,k]//posStratification//Table[{{#[[ampDimensionB1]],m},dimFunc[#[[ampDimensionB1]]]},{ampDimensionB1,#//Length}]&;,displayProgress[ampDimensionB1/depth]]];
If[$cachePrivate,calc//dataSave[ampDimension,n,k,m][#]&]
]

ampDimension::firstSave=messages["first"]["save"][n,k,m];
ampDimension::firstLoad=messages["first"]["load"][n,k,m];
ampDimension::firstFly=messages["first"]["fly"][n,k,m];
ampDimension[m_/;IntegerQ[m]&&m>0,options:OptionsPattern[]][perm_/;legalListPermQ[perm]]:=Block[{k=permK[perm],n=Length[perm],filename},
filename=dataFilename[ampDimension,n,k,m];
If[FileExistsQ[filename],
Message[ampDimension::firstLoad,n,k,m,filename];
dataLoad[ampDimension,n,k,m];
ampDimension[m][perm],
If[$cachePrivate,
Message[ampDimension::firstSave,n,k,m,filename];
defineAmpDimension[m,options][n,k];
ampDimension[m][perm],
Message[ampDimension::firstFly,n,k,m];
If[OptionValue[version]==2,ampDimensionv2[m][perm],ampDimensionv1[m][perm]]
]
]
]/;(permK[perm]+m<=Length[perm])

ampDimension[perm_/;legalListPermQ[perm],options:OptionsPattern[]]:=ampDimension[OptionValue[m],options][perm]

ampDimension::badargsM=messages["badargs"][m,"a positive integer"][1,0];
ampDimension::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampDimension::badargsBound=messages["badargs"]["bound"]["permK[perm]+m\[LessEqual]Length[perm]"];
ampDimension[m_][perm_]:=(Message[ampDimension::badargsM];$Failed)/;Not[IntegerQ[m]&&m>0]
ampDimension[m_][perm_]:=(Message[ampDimension::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampDimension[m_][perm_]:=(Message[ampDimension::badargsBound];$Failed)/;Not[permK[perm]+m<=Length[perm]]


(* ::Input::Initialization:: *)
ampFaceQ[m_/;IntegerQ[m]&&m>0][perm_/;legalListPermQ[perm]]:=(ampFaceQ[m][perm]=True)/;(m permK[perm]==ampDimension[m][perm]&&permK[perm]//#(Length[perm]-#)==posDimension[perm]&)
ampFaceQ[m_/;IntegerQ[m]&&m>0][perm_/;legalListPermQ[perm]]:=(ampFaceQ[m][perm]=Block[{ampDim=ampDimension[m][perm]},
posInverseBoundaries[1][perm]//Select[#,ampDimension[m][#]==ampDim&]&//Length[#]==0&
])/;(permK[perm]+m<=Length[perm])
ampFaceQ[perm_/;legalListPermQ[perm],OptionsPattern[{m->ampDefaults["m"]}]]:=ampFaceQ[OptionValue[m]][perm]

ampFaceQ::badargsM=messages["badargs"][m,"a positive integer"][1,0];
ampFaceQ::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampFaceQ::badargsBound=messages["badargs"]["bound"]["permK[perm]+m\[LessEqual]Length[perm]"];
ampFaceQ[m_][perm_]:=(Message[ampFaceQ::badargsM];$Failed)/;Not[IntegerQ[m]&&m>0]
ampFaceQ[m_][perm_]:=(Message[ampFaceQ::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampFaceQ[m_][perm_]:=(Message[ampFaceQ::badargsBound];$Failed)/;Not[permK[perm]+m<=Length[perm]]


(* ::Input::Initialization:: *)
ampFaces[m_/;IntegerQ[m]&&m>0][perm_/;legalListPermQ[perm]]:=(ampFaces[m][perm]=posStratification[perm]//Select[#,ampFaceQ[m]]&)/;(permK[perm]+m<=Length[perm])
ampFaces[perm_/;legalListPermQ[perm],OptionsPattern[{m->ampDefaults["m"]}]]:=ampFaces[OptionValue[m]][perm]

ampFaces::badargsM=messages["badargs"][m,"a positive integer"][1,0];
ampFaces::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampFaces::badargsBound=messages["badargs"]["bound"]["permK[perm]+m\[LessEqual]Length[perm]"];
ampFaces[m_][perm_]:=(Message[ampFaces::badargsM];$Failed)/;Not[IntegerQ[m]&&m>0]
ampFaces[m_][perm_]:=(Message[ampFaces::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampFaces[m_][perm_]:=(Message[ampFaces::badargsBound];$Failed)/;Not[permK[perm]+m<=Length[perm]]


(* ::Input::Initialization:: *)
ampBoundaries[m_/;IntegerQ[m]&&m>0&&Mod[m,2]==0,0][perm_/;isTopCellQ[perm]]:=(ampBoundaries[m,0][perm]={perm})/;(permK[perm]+m<=Length[perm])

ampBoundaries[m_/;IntegerQ[m]&&m>0&&Mod[m,2]==0,1][perm_/;isTopCellQ[perm]]:=(ampBoundaries[m,1][perm]=Block[{k=permK[perm],n=Length[perm],candidates,matrices,minors},
candidates=ampFaces[m][perm]//Select[#,ampDimension[m][#]==m k -1&]&;
matrices=candidates//permToMat/@#&//#.Transpose[positiveMatrix[k+m,n]]&/@#&;
minors=Range[n]//{#,Mod[#,n]+1}&/@#&//Subsets[#,{m/2}]&//Select[#,Length[Union@@#]==Length[Flatten@#]&]&//Flatten/@#&//Transpose[positiveMatrix[k+m,n]][[#]]&/@#&;
Table[If[Det[Join[matrices[[A2]],minors[[A1]]]]//isZeroQ,A2,0],{A1,minors//Length},{A2,matrices//Length}]//Flatten//DeleteCases[#,0]&//candidates[[#]]&
])/;(permK[perm]+m<=Length[perm])

ampBoundaries[m_/;IntegerQ[m]&&m>0&&Mod[m,2]==0,codim_/;IntegerQ[codim]&&codim>1][perm_/;isTopCellQ[perm]]:=(ampBoundaries[m,codim][perm]=Block[{k=permK[perm],above=ampBoundaries[m,codim-1][perm]},
ampFaces[m][perm]//Select[#,ampDimension[m][#]==m k -codim&]&//Select[#,Length[Intersection[posInverseStratification[#],above]]>1&]&
])/;(permK[perm]+m<=Length[perm]&&codim<=m permK[perm])

ampBoundaries[codim_,OptionsPattern[{m->ampDefaults["m"]}]][perm_]:=ampBoundaries[OptionValue[m],codim][perm]

ampBoundaries::badargsM=messages["badargs"][m,"a positive even number"][1,1];
ampBoundaries::badargsCodim=messages["badargs"][codim,"a non-negative integer"][1,2];
ampBoundaries::badargsPerm=messages["badargs"][perm,"an affine permutation labelling a top-cell"][2,0];
ampBoundaries::badargsBound1=messages["badargs"]["bound"]["permK[perm]+m\[LessEqual]Length[perm]"];
ampBoundaries::badargsBound2=messages["badargs"]["bound"]["codim\[LessEqual]m*permK[perm]"];
ampBoundaries[m_,codim_][perm_]:=(Message[ampBoundaries::badargsM];$Failed)/;Not[IntegerQ[m]&&m>0&&Mod[m,2]==0]
ampBoundaries[m_,codim_][perm_]:=(Message[ampBoundaries::badargsCodim];$Failed)/;Not[IntegerQ[codim]&&codim>=0]
ampBoundaries[m_,codim_][perm_]:=(Message[ampBoundaries::badargsPerm];$Failed)/;Not[isTopCellQ[perm]]
ampBoundaries[m_,codim_][perm_]:=(Message[ampBoundaries::badargsBound1];$Failed)/;Not[permK[perm]+m<=Length[perm]]
ampBoundaries[m_,codim_][perm_]:=(Message[ampBoundaries::badargsBound2];$Failed)/;Not[codim<=m permK[perm]]


(* ::Input::Initialization:: *)
ampStratificationCalc[m_/;IntegerQ[m]&&m>0&&Mod[m,2]==0][perm_/;isTopCellQ[perm]]:=(ampStratification[m][perm]=Block[{k=permK[perm],boundaries},
boundaries=Monitor[Table[ampBoundaries[m,ampStratificationB1][perm],{ampStratificationB1,0,m k}]//Flatten[#,1]&,displayProgress[ampStratificationB1/(m k)]];
boundaries
])/;(permK[perm]+m<=Length[perm])

ampStratification::firstSave=messages["first"]["save"][n,k,m];
ampStratification::firstLoad=messages["first"]["load"][n,k,m];
ampStratification::firstFly=messages["first"]["fly"][n,k,m];
ampStratification[m_/;IntegerQ[m]&&m>0&&Mod[m,2]==0][perm_/;isTopCellQ[perm]]:=Block[{k=permK[perm],n=Length[perm],filename},
filename=dataFilename[ampStratification,n,k,m];
If[FileExistsQ[filename],
Message[ampStratification::firstLoad,n,k,m,filename];
dataLoad[ampStratification,n,k,m];
ampStratification[m][perm],
ampDimension[m][perm];
If[$cachePrivate,
Message[ampStratification::firstSave,n,k,m,filename];{{{perm,m},ampStratificationCalc[m][perm]}}//dataSave[ampStratification,n,k,m][#]&;
ampStratification[m][perm],
Message[ampStratification::firstFly,n,k,m];
ampStratificationCalc[m][perm]
]]
]/;(permK[perm]+m<=Length[perm])

ampStratificationCalc[m_/;IntegerQ[m]&&m>0&&Mod[m,2]==0][perm_/;legalListPermQ[perm]]:=(ampStratification[m][perm]=Intersection[posStratification[perm],ampStratification[m][topCell[Length[perm],permK[perm]]]])/;((permK[perm]+m<=Length[perm])&&MemberQ[ampStratification[m][topCell[Length[perm],permK[perm]]],perm])

ampStratification[m_/;IntegerQ[m]&&m>0&&Mod[m,2]==0][perm_/;legalListPermQ[perm]]:=ampStratificationCalc[m][perm]/;((permK[perm]+m<=Length[perm])&&MemberQ[ampStratification[m][topCell[Length[perm],permK[perm]]],perm])

ampStratification[perm_/;legalListPermQ[perm],OptionsPattern[{m->ampDefaults["m"]}]]:=ampStratification[OptionValue[m]][perm]

ampStratification::badargsM=messages["badargs"][m,"a positive even number"][1,0];
ampStratification::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampStratification::badargsIn=messages["badargs"][perm,"a cell in the amplituhedron"][2,0];
ampStratification::badargsBound=messages["badargs"]["bound"]["permK[perm]+m\[LessEqual]Length[perm]"];
ampStratification[m_][perm_]:=(Message[ampStratification::badargsM];$Failed)/;Not[IntegerQ[m]&&m>0&&Mod[m,2]==0]
ampStratification[m_][perm_]:=(Message[ampStratification::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampStratification[m_][perm_]:=(Message[ampStratification::badargsBound];
$Failed)/;Not[permK[perm]+m<=Length[perm]]
ampStratification[m_][perm_]:=(Message[ampStratification::badargsIn];$Failed)


(* ::Input::Initialization:: *)
ampInverseStratification[m_/;IntegerQ[m]&&m>0&&Mod[m,2]==0][perm_/;legalListPermQ[perm]]:=(ampInverseStratification[m][perm]=Intersection[posInverseStratification[perm],ampStratification[m][topCell[Length[perm],permK[perm]]]])/;((permK[perm]+m<=Length[perm])&&MemberQ[ampStratification[m][topCell[Length[perm],permK[perm]]],perm])

ampInverseStratification[perm_/;legalListPermQ[perm],OptionsPattern[{m->ampDefaults["m"]}]]:=ampInverseStratification[OptionValue[m]][perm]

ampInverseStratification::badargsM=messages["badargs"][m,"a positive even number"][1,0];
ampInverseStratification::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampInverseStratification::badargsIn=messages["badargs"][perm,"a cell in the amplituhedron"][2,0];
ampInverseStratification::badargsBound=messages["badargs"]["bound"]["permK[perm]+m\[LessEqual]Length[perm]"];
ampInverseStratification[m_][perm_]:=(Message[ampInverseStratification::badargsM];$Failed)/;Not[IntegerQ[m]&&m>0&&Mod[m,2]==0]
ampInverseStratification[m_][perm_]:=(Message[ampInverseStratification::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampInverseStratification[m_][perm_]:=(Message[ampInverseStratification::badargsBound];
$Failed)/;Not[permK[perm]+m<=Length[perm]]
ampInverseStratification[m_][perm_]:=(Message[ampInverseStratification::badargsIn];$Failed)/;Not[MemberQ[ampStratification[m][topCell[Length[perm],permK[perm]]],perm]]


(* ::Input::Initialization:: *)
ampBoundary[2][perm_/;legalListPermQ[perm]]:=(ampBoundary[2][perm]=Select[ampStratification[2][perm],ampDimension[2][#]==ampDimension[2][perm]-1&])/;((permK[perm]+2<=Length[perm])&&MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm])

ampBoundary[perm_/;legalListPermQ[perm],OptionsPattern[{m->ampDefaults["m"]}]]:=ampBoundary[OptionValue[m]][perm]

ampBoundary::badargsM=messages["badargs"]["implemented"]["m\[Equal]2"];
ampBoundary::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampBoundary::badargsIn=messages["badargs"][perm,"a cell in the amplituhedron"][2,0];
ampBoundary::badargsBound=messages["badargs"]["bound"]["permK[perm]+m\[LessEqual]Length[perm]"];
ampBoundary[m_][perm_]:=(Message[ampBoundary::badargsM];$Failed)/;Not[m==2]
ampBoundary[m_][perm_]:=(Message[ampBoundary::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampBoundary[m_][perm_]:=(Message[ampBoundary::badargsBound];
$Failed)/;Not[permK[perm]+m<=Length[perm]]
ampBoundary[m_][perm_]:=(Message[ampBoundary::badargsIn];$Failed)/;Not[MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm]]


(* ::Input::Initialization:: *)
ampInverseBoundary[2][perm_/;legalListPermQ[perm]]:=(ampInverseBoundary[2][perm]=Select[ampInverseStratification[2][perm],ampDimension[2][#]==ampDimension[2][perm]+1&])/;((permK[perm]+2<=Length[perm])&&MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm])

ampInverseBoundary[perm_/;legalListPermQ[perm],OptionsPattern[{m->ampDefaults["m"]}]]:=ampInverseBoundary[OptionValue[m]][perm]

ampInverseBoundary::badargsM=messages["badargs"]["implemented"]["m\[Equal]2"];
ampInverseBoundary::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampInverseBoundary::badargsIn=messages["badargs"][perm,"a cell in the amplituhedron"][2,0];
ampInverseBoundary::badargsBound=messages["badargs"]["bound"]["permK[perm]+m\[LessEqual]Length[perm]"];
ampInverseBoundary[m_][perm_]:=(Message[ampInverseBoundary::badargsM];$Failed)/;Not[m==2]
ampInverseBoundary[m_][perm_]:=(Message[ampInverseBoundary::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampInverseBoundary[m_][perm_]:=(Message[ampInverseBoundary::badargsBound];
$Failed)/;Not[permK[perm]+m<=Length[perm]]
ampInverseBoundary[m_][perm_]:=(Message[ampInverseBoundary::badargsIn];$Failed)


(* ::Input::Initialization:: *)
ampInterval[2][perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2]]:=(ampInterval[2][perm1,perm2]=Intersection[posInterval[perm1,perm2],ampStratification[2][topCell[Length[perm1],permK[perm1]]]])/;(Length[perm1]==Length[perm2]&&permK[perm1]==permK[perm2]&&(permK[perm1]+2<=Length[perm1])&&MemberQ[ampStratification[2][topCell[Length[perm1],permK[perm1]]],perm1]&&MemberQ[ampStratification[2][topCell[Length[perm2],permK[perm2]]],perm2])

ampInterval[perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2],OptionsPattern[m->ampDefaults["m"]]]:=ampInterval[OptionValue[m]][perm1,perm2]

ampInterval::badargsM=messages["badargs"]["implemented"]["m\[Equal]2"];
ampInterval::badargsPerm1=messages["badargs"][perm1,"an affine permutation"][2,1];
ampInterval::badargsPerm2=messages["badargs"][perm2,"an affine permutation"][2,2];
ampInterval::badargsIn1=messages["badargs"][perm1,"a cell in the amplituhedron"][2,1];
ampInterval::badargsIn2=messages["badargs"][perm2,"a cell in the amplituhedron"][2,2];
ampInterval::badargsLength=messages["badargs"]["bound"]["Length[perm1]\[Equal]Length[perm2]"];
ampInterval::badargsPermK=messages["badargs"]["bound"]["permK[perm1]\[Equal]permK[perm2]"];
ampInterval::badargsBound1=messages["badargs"]["bound"]["permK[perm1]+2\[LessEqual]Length[perm1]"];
ampInterval[m_][perm1_,perm2_]:=(Message[ampInterval::badargsM];$Failed)/;Not[m==2]
ampInterval[m_][perm1_,perm2_]:=(Message[ampInterval::badargsPerm1];$Failed)/;Not[legalListPermQ[perm1]]
ampInterval[m_][perm1_,perm2_]:=(Message[ampInterval::badargsPerm2];$Failed)/;Not[legalListPermQ[perm2]]
ampInterval[m_][perm1_,perm2_]:=(Message[ampInterval::badargsLength];$Failed)/;Not[Length[perm1]==Length[perm2]]
ampInterval[m_][perm1_,perm2_]:=(Message[ampInterval::badargsPermK];$Failed)/;Not[permK[perm1]==permK[perm2]]
ampInterval[m_][perm1_,perm2_]:=(Message[ampInterval::badargsBound1];$Failed)/;Not[permK[perm1]+2<=Length[perm1]]
ampInterval[m_][perm1_,perm2_]:=(Message[ampInterval::badargsIn1];$Failed)/;Not[MemberQ[ampStratification[2][topCell[Length[perm1],permK[perm1]]],perm1]]
ampInterval[m_][perm1_,perm2_]:=(Message[ampInterval::badargsIn2];$Failed)/;Not[MemberQ[ampStratification[2][topCell[Length[perm1],permK[perm2]]],perm2]]



(* ::Input::Initialization:: *)
ampPoset[2][perm_/;isTopCellQ[perm]]:=(ampPoset[2][perm]=perm//ampStratification[2]//Table[MemberQ[ampStratification[2][#[[A1]]],#[[A2]]],{A1,#//Length},{A2,#//Length}]&//Boole//AdjacencyGraph//TransitiveReductionGraph//AdjacencyMatrix)

ampPoset[2][perm_/;legalListPermQ[perm]]:=(ampPoset[2][perm]=Block[{n=Length[perm],k=permK[perm],indices},
indices=perm//ampStratification[2]//Position[topCell[Length[perm],permK[perm]]//ampStratification[2],#]&/@#&//Flatten;topCell[Length[perm],permK[perm]]//ampPoset[2]//#[[indices,indices]]&
])/;((permK[perm]+2<=Length[perm])&&MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm])

ampPoset[2][perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2]]:=(ampPoset[2][perm1,perm2]=Block[{n=Length[perm1],k=permK[perm1],indices},
indices=ampInterval[2][perm1,perm2]//Position[topCell[n,k]//ampStratification[2],#]&/@#&//Flatten;
topCell[n,k]//ampPoset[2]//#[[indices,indices]]&
])/;(Length[perm1]==Length[perm2]&&permK[perm1]==permK[perm2]&&(permK[perm1]+2<=Length[perm1])&&MemberQ[ampStratification[2][topCell[Length[perm1],permK[perm1]]],perm1]&&MemberQ[ampStratification[2][topCell[Length[perm2],permK[perm2]]],perm2])

ampPoset[perm_/;legalListPermQ[perm],OptionsPattern[{m->ampDefaults["m"]}]]:=ampPoset[OptionValue[m]][perm]
ampPoset[perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2],OptionsPattern[m->ampDefaults["m"]]]:=ampPoset[OptionValue[m]][perm1,perm2]

ampPoset::badargsM=messages["badargs"]["implemented"]["m\[Equal]2"];
ampPoset::badargsPerm1=messages["badargs"][perm1,"an affine permutation"][2,1];
ampPoset::badargsPerm2=messages["badargs"][perm2,"an affine permutation"][2,2];
ampPoset::badargsIn1=messages["badargs"][perm1,"a cell in the amplituhedron"][2,1];
ampPoset::badargsIn2=messages["badargs"][perm2,"a cell in the amplituhedron"][2,2];
ampPoset::badargsLength=messages["badargs"]["bound"]["Length[perm1]\[Equal]Length[perm2]"];
ampPoset::badargsPermK=messages["badargs"]["bound"]["permK[perm1]\[Equal]permK[perm2]"];
ampPoset::badargsBound1=messages["badargs"]["bound"]["permK[perm1]+2\[LessEqual]Length[perm1]"];
ampPoset[m_][perm1_,perm2_]:=(Message[ampPoset::badargsM];$Failed)/;Not[m==2]
ampPoset[m_][perm1_,perm2_]:=(Message[ampPoset::badargsPerm1];$Failed)/;Not[legalListPermQ[perm1]]
ampPoset[m_][perm1_,perm2_]:=(Message[ampPoset::badargsPerm2];$Failed)/;Not[legalListPermQ[perm2]]
ampPoset[m_][perm1_,perm2_]:=(Message[ampPoset::badargsLength];$Failed)/;Not[Length[perm1]==Length[perm2]]
ampPoset[m_][perm1_,perm2_]:=(Message[ampPoset::badargsPermK];$Failed)/;Not[permK[perm1]==permK[perm2]]
ampPoset[m_][perm1_,perm2_]:=(Message[ampPoset::badargsBound1];$Failed)/;Not[permK[perm1]+2<=Length[perm1]]
ampPoset[m_][perm1_,perm2_]:=(Message[ampPoset::badargsIn1];$Failed)/;Not[MemberQ[ampStratification[2][topCell[Length[perm1],permK[perm1]]],perm1]]
ampPoset[m_][perm1_,perm2_]:=(Message[ampPoset::badargsIn2];$Failed)/;Not[MemberQ[ampStratification[2][topCell[Length[perm1],permK[perm2]]],perm2]]

ampPoset::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampPoset::badargsIn=messages["badargs"][perm,"a cell in the amplituhedron"][2,0];
ampPoset::badargsBound=messages["badargs"]["bound"]["permK[perm]+2\[LessEqual]Length[perm]"];
ampPoset[m_][perm_]:=(Message[ampPoset::badargsM];$Failed)/;Not[m==2]
ampPoset[m_][perm_]:=(Message[ampPoset::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampPoset[m_][perm_]:=(Message[ampPoset::badargsIn];$Failed)/;Not[MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm]]
ampPoset[m_][perm_]:=(Message[ampPoset::badargsBound];$Failed)/;Not[(permK[perm]+2<=Length[perm])]


(* ::Input::Initialization:: *)
momLambda[n_/;IntegerQ[n],k_/;IntegerQ[k],m_/;MemberQ[{2,4},m]]/;(m/2<=k<=n-m/2):=(momLambda[n,k,m]=If[k==m/2,IdentityMatrix[n],positiveMatrix[k-m/2,n]//orthComplement])
Options[momLambda]={m->momDefaults["m"]};
momLambda[n_,k_,OptionsPattern[]]:=momLambda[n,k,OptionValue[m]]

momLambdaT[n_/;IntegerQ[n],k_/;IntegerQ[k],m_/;MemberQ[{2,4},m]]/;(m/2<=k<=n-m/2):=(momLambdaT[n,k,m]=positiveMatrix[k+m/2,n])
Options[momLambdaT]=Options[momLambda];
momLambdaT[n_,k_,OptionsPattern[]]:=momLambdaT[n,k,OptionValue[m]]


(* ::Input::Initialization:: *)
momY[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]]:=(momY[m][perm]=orthComplement[permToMat[perm]].Transpose[momLambda[Length[perm],permK[perm],m]])/;(m/2<=permK[perm]<=Length[perm]-m/2)
Options[momY]=Options[momLambda];
momY[perm_/;legalListPermQ[perm],OptionsPattern[]]:=momY[OptionValue[m]][perm]

momYT[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]]:=(momYT[m][perm]=permToMat[perm].Transpose[momLambdaT[Length[perm],permK[perm],m]])/;(m/2<=permK[perm]<=Length[perm]-m/2)
Options[momYT]=Options[momLambda];
momYT[perm_/;legalListPermQ[perm],OptionsPattern[]]:=momYT[OptionValue[m]][perm]


(* ::Input::Initialization:: *)
momMap[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]]:=(momMap[m][perm]={momYT[m][perm],momY[m][perm]})/;(m/2<=permK[perm]<=Length[perm]-m/2)
momMap[perm_/;legalListPermQ[perm],OptionsPattern[]]:=momMap[OptionValue[m]][perm]

momMap::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momMap::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
momMap::badargsBound=messages["badargs"]["bound"]["m/2\[LessEqual]permK[perm]\[LessEqual]Length[perm]-m/2"];
momMap[m_][perm_]:=(Message[momMap::badargsM];$Failed)/;Not[MemberQ[{2,4},m]]
momMap[m_][perm_]:=(Message[momMap::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
momMap[m_][perm_]:=(Message[momMap::badargsBound];$Failed)/;Not[m/2<=permK[perm]<=Length[perm]-m/2]


(* ::Input::Initialization:: *)
(* hard code top cell and zero cells *)
momDimensionv1[m_/;MemberQ[{2,4},m]][perm_/;isTopCellQ[perm]]:=(momDimension[m][perm]=m/4(2Length[perm]-m))
momDimensionv1[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]&&(posDimension[perm]==0)]:=(momDimension[m][perm]=0)
(* only calculate for single representative from each cyclicRep equivalence class *)
momDimensionv1[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]&&perm==Global`cyclicRep[perm]]:=(momDimension[m][perm]=Block[{YT=momYT[m][perm],Y=momY[m][perm],k=permK[perm],n=Length[perm],g,glTransformation,dim},
glTransformation[1]=Table[Subscript[g[1], A1,A2],{A1,k},{A2,k}];
glTransformation[2]=Table[Subscript[g[2], A1,A2],{A1,n-k},{A2,n-k}];
dim={glTransformation[1].YT,glTransformation[2].Y}//Flatten//Table[D[#,A1],{A1,Join[Table[Global`\[Alpha][A1],{A1,posDimension[perm]}],glTransformation[1],glTransformation[2]]//Flatten}]&//MatrixRank//#-k^2-(n-k)^2&;
momDimensionv1[m][perm]=dim;
dim
])/;(m/2<=permK[perm]<=Length[perm]-m/2)
momDimensionv1[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]]:=(momDimension[m][perm]=momDimensionv1[m][Global`cyclicRep[perm]])

momDimensionv2[m_/;MemberQ[{2,4},m]][perm_/;isTopCellQ[perm]]:=(momDimension[m][perm]=m/4(2Length[perm]-m))
momDimensionv2[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]&&(posDimension[perm]==0)]:=(momDimension[m][perm]=0)
momDimensionv2[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]&&perm==Global`cyclicRep[perm]]:=(momDimension[m][perm]=Block[{phi={momYT[m][perm],momY[m][perm]},k=permK[perm],n=Length[perm],dims,gauge,denom,coords,dim},
dims={k,n-k};
gauge=Table[Subsets[Range[dims[[A1]]+m/2],{dims[[A1]]}]//Select[#,!isZeroQ[Det[phi[[A1]][[;;,#]]]]&]&//#[[1]]&,{A1,2}];
denom=Table[Det[phi[[A1]][[;;,gauge[[A1]]]]],{A1,2}];
coords=Table[Subsets[Range[dims[[A1]]+m/2],{dims[[A1]]}]//Select[#,Length[Intersection[gauge[[A1]],#]]==dims[[A1]]-1&]&//phi[[A1]][[;;,#]]&/@#&//Det/@#&,{A1,2}];
dim=Table[coords[[A1]]/denom[[A1]],{A1,2}]//Flatten//Table[D[#,A1],{A1,Table[Global`\[Alpha][A2],{A2,posDimension[perm]}]}]&//MatrixRank;
momDimensionv2[m][perm]=dim;
dim
])/;(m/2<=permK[perm]<=Length[perm]-m/2)
momDimensionv2[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]]:=(momDimension[m][perm]=momDimensionv2[m][Global`cyclicRep[perm]])

Options[momDimension]={m->momDefaults["m"],version->2};
Options[defineMomDimension]=Options[momDimension];

defineMomDimension[m_,options:OptionsPattern[]][n_,k_]:=Block[{filename=dataFilename[momDimension,n,k,m],depth,calc,dimFunc},
If[!FileExistsQ[filename],
dimFunc=If[OptionValue[version]==1,momDimensionv1[m],momDimensionv2[m]];
depth=posStratificationSize[topCell[n,k]];Monitor[calc=topCell[n,k]//posStratification//Table[{{#[[momDimensionB1]],m},dimFunc[#[[momDimensionB1]]]},{momDimensionB1,#//Length}]&;,displayProgress[momDimensionB1/depth]]];
If[$cachePrivate,calc//dataSave[momDimension,n,k,m][#]&]
]

momDimension::firstSave=messages["first"]["save"][n,k,m];
momDimension::firstLoad=messages["first"]["load"][n,k,m];
momDimension::firstFly=messages["first"]["fly"][n,k,m];

momDimension[m_/;MemberQ[{2,4},m],options:OptionsPattern[]][perm_/;legalListPermQ[perm]]:=Block[{k=permK[perm],n=Length[perm],filename},
filename=dataFilename[momDimension,n,k,m];
If[FileExistsQ[filename],
Message[momDimension::firstLoad,n,k,m,filename];
dataLoad[momDimension,n,k,m];
momDimension[m][perm],
If[$cachePrivate,
Message[momDimension::firstSave,n,k,m,filename];
defineMomDimension[m,options][n,k];
momDimension[m][perm],
Message[momDimension::firstFly,n,k,m];
If[OptionValue[version]==1,momDimensionv1[m][perm],momDimensionv2[m][perm]]
]
]
]/;(m/2<=permK[perm]<=Length[perm]-m/2)

momDimension[perm_/;legalListPermQ[perm],options:OptionsPattern[]]:=momDimension[OptionValue[m],options][perm]

momDimension::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momDimension::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
momDimension::badargsBound=messages["badargs"]["bound"]["m/2\[LessEqual]permK[perm]\[LessEqual]Length[perm]-m/2"];
momDimension[m_][perm_]:=(Message[momDimension::badargsM];$Failed)/;Not[MemberQ[{2,4},m]]
momDimension[m_][perm_]:=(Message[momDimension::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
momDimension[m_][perm_]:=(Message[momDimension::badargsBound];$Failed)/;Not[m/2<=permK[perm]<=Length[perm]-m/2]


(* ::Input::Initialization:: *)
momFaceQ[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]]:=(momFaceQ[m][perm]=True)/;(m/2<=permK[perm]<=Length[perm]-m/2&&m/4(2 Length[perm]-m)==momDimension[m][perm]&&permK[perm]//#(Length[perm]-#)==posDimension[perm]&)
momFaceQ[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]]:=(momFaceQ[m][perm]=Block[{momDim=momDimension[m][perm]},
posInverseBoundaries[1][perm]//Select[#,momDimension[m][#]==momDim&]&//Length[#]==0&
])/;(m/2<=permK[perm]<=Length[perm]-m/2)
momFaceQ[perm_/;legalListPermQ[perm],OptionsPattern[{m->momDefaults["m"]}]]:=momFaceQ[OptionValue[m]][perm]

momFaceQ::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momFaceQ::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
momFaceQ::badargsBound=messages["badargs"]["bound"]["m/2\[LessEqual]permK[perm]\[LessEqual]Length[perm]-m/2"];
momFaceQ[m_][perm_]:=(Message[momFaceQ::badargsM];$Failed)/;Not[MemberQ[{2,4},m]]
momFaceQ[m_][perm_]:=(Message[momFaceQ::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
momFaceQ[m_][perm_]:=(Message[momFaceQ::badargsBound];$Failed)/;Not[m/2<=permK[perm]<=Length[perm]-m/2]


(* ::Input::Initialization:: *)
momFaces[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]]:=(momFaces[m][perm]=posStratification[perm]//Select[#,momFaceQ[m]]&)/;(m/2<=permK[perm]<=Length[perm]-m/2)
momFaces[perm_/;legalListPermQ[perm],OptionsPattern[{m->momDefaults["m"]}]]:=momFaces[OptionValue[m]][perm]

momFaces::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momFaces::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
momFaces::badargsBound=messages["badargs"]["bound"]["m/2\[LessEqual]permK[perm]\[LessEqual]Length[perm]-m/2"];
momFaces[m_][perm_]:=(Message[momFaces::badargsM];$Failed)/;Not[MemberQ[{2,4},m]]
momFaces[m_][perm_]:=(Message[momFaces::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
momFaces[m_][perm_]:=(Message[momFaces::badargsBound];$Failed)/;Not[m/2<=permK[perm]<=Length[perm]-m/2]


(* ::Input::Initialization:: *)
indicesQ[n_/;IntegerQ[n]&&n>0][x__]:=Table[IntegerQ[A1]&&0<A1<=n,{A1,x}]//Flatten//Not[MemberQ[#,False]]&


(* ::Input::Initialization:: *)
momIP[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]][indices__]:=(momIP[m][perm][indices]=Det@Join[momY[m][perm],Transpose@momLambda[Length[perm],permK[perm],m][[;;,{indices}]]])/;((m/2<=permK[perm]<=Length[perm]-m/2)&&(Length[List@indices]==m/2)&&indicesQ[Length[perm]][indices])

momIPT[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]][indices__]:=(momIPT[m][perm][indices]=Det@Join[momYT[m][perm],Transpose@momLambdaT[Length[perm],permK[perm],m][[;;,{indices}]]])/;((m/2<=permK[perm]<=Length[perm]-m/2)&&(Length[List@indices]==m/2)&&indicesQ[Length[perm]][indices])


(* ::Input::Initialization:: *)
momMandelstamS[perm_/;legalListPermQ[perm]][i_/;IntegerQ[i]&&i>0,p_/;IntegerQ[p]]:=(momMandelstamS[perm][i,p]=Range[i,p+i]//Subsets[#,{2}]&//Mod[#-1,Length[perm]]+1&/@#&//Sum[(momIP[4][perm]@@A1)(momIPT[4][perm]@@A1),{A1,#}]&//Simplify)/;(2<=permK[perm]<=Length[perm]-2&&i<=Length[perm]&&2<=p<=Length[perm]-4)


(* ::Input::Initialization:: *)
momBoundaries[m_/;MemberQ[{2,4},m],0][perm_/;isTopCellQ[perm]]:=(momBoundaries[m,0][perm]={perm})/;(m/2<=permK[perm]<=Length[perm]-m/2)

momBoundaries[m_/;MemberQ[{2,4},m],1][perm_/;isTopCellQ[perm]]:=(momBoundaries[m,1][perm]=Block[{n=Length[perm],candidates,conseqPairs,mandelIndices,codim1},
candidates=momFaces[m][perm]//Select[#,momDimension[m][#]==m/4(2n-m)-1&]&;
conseqPairs=Range[n]//If[m==2,{#}&,If[m==4,{#,Mod[#,n]+1}&]]/@#&;
mandelIndices=If[m==4,Table[{A1,A2},{A1,n},{A2,m/2,n-2-m/2}]//Flatten[#,1]&,{}];
codim1[1]=Select[candidates,MemberQ[Table[isZeroQ[momIPT[m][#]@@A1],{A1,conseqPairs}],True]&];
codim1[2]=Select[candidates,MemberQ[Table[isZeroQ[momIP[m][#]@@A1],{A1,conseqPairs}],True]&];
codim1[3]=If[Length[mandelIndices]==0,{},Select[candidates,MemberQ[Table[isZeroQ[momMandelstamS[#]@@A1],{A1,mandelIndices}],True]&]];
Table[codim1[A1],{A1,3}]//Flatten[#,1]&//DeleteDuplicates
])/;(m/2<=permK[perm]<=Length[perm]-m/2)

momBoundaries[m_/;MemberQ[{2,4},m],codim_/;IntegerQ[codim]&&codim>1][perm_/;isTopCellQ[perm]]:=(momBoundaries[m,codim][perm]=Block[{n=Length[perm],above},
above=momBoundaries[m,codim-1][perm];
momFaces[m][perm]//Select[#,momDimension[m][#]==m/4(2n-m) -codim&]&//Select[#,Length[Intersection[posInverseStratification[#],above]]>1&]&
])/;(m/2<=permK[perm]<=Length[perm]-m/2&&codim<=m/4 (2Length[perm]-m))

momBoundaries[codim_,OptionsPattern[{m->momDefaults["m"]}]][perm_]:=momBoundaries[OptionValue[m],codim][perm]

momBoundaries::badargsM=messages["badargs"][m,"2 or 4"][1,1];
momBoundaries::badargsCodim=messages["badargs"][codim,"a non-negative integer"][1,2];
momBoundaries::badargsPerm=messages["badargs"][perm,"an affine permutation labelling a top-cell"][2,0];
momBoundaries::badargsBound1=messages["badargs"]["bound"]["m/2\[LessEqual]permK[perm]\[LessEqual]Length[perm]-m/2"];
momBoundaries::badargsBound2=messages["badargs"]["bound"]["codim\[LessEqual]m/4*(2*Length[perm]-m)"];
momBoundaries[m_,codim_][perm_]:=(Message[momBoundaries::badargsM];$Failed)/;Not[MemberQ[{2,4},m]]
momBoundaries[m_,codim_][perm_]:=(Message[momBoundaries::badargsCodim];$Failed)/;Not[IntegerQ[codim]&&codim>=0]
momBoundaries[m_,codim_][perm_]:=(Message[momBoundaries::badargsPerm];$Failed)/;Not[isTopCellQ[perm]]
momBoundaries[m_,codim_][perm_]:=(Message[momBoundaries::badargsBound1];$Failed)/;Not[m/2<=permK[perm]<=Length[perm]-m/2]
momBoundaries[m_,codim_][perm_]:=(Message[momBoundaries::badargsBound2];$Failed)/;Not[codim<=m/4 (2Length[perm]-m)]


(* ::Input::Initialization:: *)
momStratificationCalc[m_/;MemberQ[{2,4},m]][perm_/;isTopCellQ[perm]]:=(momStratification[m][perm]=Block[{n=Length[perm],dim,boundaries},
dim =m/4(2n-m);
boundaries=Monitor[Table[momBoundaries[m,momStratificationB1][perm],{momStratificationB1,0,dim}]//Flatten[#,1]&,displayProgress[momStratificationB1/dim]];
boundaries
])/;(m/2<=permK[perm]<=Length[perm]-m/2)

momStratification::firstSave=messages["first"]["save"][n,k,m];
momStratification::firstLoad=messages["first"]["load"][n,k,m];
momStratification::firstFly=messages["first"]["fly"][n,k,m];
momStratification[m_/;MemberQ[{2,4},m]][perm_/;isTopCellQ[perm]]:=Block[{k=permK[perm],n=Length[perm],filename},
filename=dataFilename[momStratification,n,k,m];
If[FileExistsQ[filename],
Message[momStratification::firstLoad,n,k,m,filename];
dataLoad[momStratification,n,k,m];
momStratification[m][perm],
momDimension[m][perm];
If[$cachePrivate,
Message[momStratification::firstSave,n,k,m,filename];{{{perm,m},momStratificationCalc[m][perm]}}//dataSave[momStratification,n,k,m][#]&;
momStratification[m][perm],
Message[momStratification::firstFly,n,k,m];
momStratificationCalc[m][perm]
]]
]/;(m/2<=permK[perm]<=Length[perm]-m/2)

momStratificationCalc[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]]:=(momStratification[m][perm]=Intersection[posStratification[perm],momStratification[m][topCell[Length[perm],permK[perm]]]])/;((m/2<=permK[perm]<=Length[perm]-m/2)&&MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm])
momStratification[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]]:=momStratificationCalc[m][perm]/;((m/2<=permK[perm]<=Length[perm]-m/2)&&MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm])

momStratification[perm_/;legalListPermQ[perm],OptionsPattern[{m->momDefaults["m"]}]]:=momStratification[OptionValue[m]][perm]

momStratification::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momStratification::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
momStratification::badargsIn=messages["badargs"][perm,"a cell in the momentum amplituhedron"][2,0];
momStratification::badargsBound=messages["badargs"]["bound"]["m/2\[LessEqual]permK[perm]\[LessEqual]Length[perm]-m/2"];
momStratification[m_][perm_]:=(Message[momStratification::badargsM];$Failed)/;Not[MemberQ[{2,4},m]]
momStratification[m_][perm_]:=(Message[momStratification::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
momStratification[m_][perm_]:=(Message[momStratification::badargsBound];
$Failed)/;Not[m/2<=permK[perm]<=Length[perm]-m/2]
momStratification[m_][perm_]:=(Message[momStratification::badargsIn];$Failed)


(* ::Input::Initialization:: *)
momInverseStratification[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]]:=(momInverseStratification[m][perm]=Intersection[posInverseStratification[perm],momStratification[m][topCell[Length[perm],permK[perm]]]])/;((m/2<=permK[perm]<=Length[perm]-m/2)&&MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm])

momInverseStratification[perm_/;legalListPermQ[perm],OptionsPattern[{m->momDefaults["m"]}]]:=momInverseStratification[OptionValue[m]][perm]

momInverseStratification::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momInverseStratification::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
momInverseStratification::badargsIn=messages["badargs"][perm,"a cell in the momentum amplituhedron"][2,0];
momInverseStratification::badargsBound=messages["badargs"]["bound"]["m/2\[LessEqual]permK[perm]\[LessEqual]Length[perm]-m/2"];
momInverseStratification[m_][perm_]:=(Message[momInverseStratification::badargsM];$Failed)/;Not[MemberQ[{2,4},m]]
momInverseStratification[m_][perm_]:=(Message[momInverseStratification::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
momInverseStratification[m_][perm_]:=(Message[momInverseStratification::badargsBound];
$Failed)/;Not[m/2<=permK[perm]<=Length[perm]-m/2]
momInverseStratification[m_][perm_]:=(Message[momInverseStratification::badargsIn];$Failed)/;Not[MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm]]


(* ::Input::Initialization:: *)
momBoundary[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]]:=(momBoundary[m][perm]=Select[momStratification[m][perm],momDimension[m][#]==momDimension[m][perm]-1&])/;((m/2<=permK[perm]<=Length[perm]-m/2)&&MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm])

momBoundary[perm_/;legalListPermQ[perm],OptionsPattern[{m->momDefaults["m"]}]]:=momBoundary[OptionValue[m]][perm]

momBoundary::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momBoundary::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
momBoundary::badargsIn=messages["badargs"][perm,"a cell in the momentum amplituhedron"][2,0];
momBoundary::badargsBound=messages["badargs"]["bound"]["m/2\[LessEqual]permK[perm]\[LessEqual]Length[perm]-m/2"];
momBoundary[m_][perm_]:=(Message[momBoundary::badargsM];$Failed)/;Not[MemberQ[{2,4},m]]
momBoundary[m_][perm_]:=(Message[momBoundary::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
momBoundary[m_][perm_]:=(Message[momBoundary::badargsBound];
$Failed)/;Not[m/2<=permK[perm]<=Length[perm]-m/2]
momBoundary[m_][perm_]:=(Message[momBoundary::badargsIn];$Failed)/;Not[MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm]]


(* ::Input::Initialization:: *)
momInverseBoundary[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]]:=(momInverseBoundary[m][perm]=Select[momInverseStratification[m][perm],momDimension[m][#]==momDimension[m][perm]+1&])/;((m/2<=permK[perm]<=Length[perm]-m/2)&&MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm])

momInverseBoundary[perm_/;legalListPermQ[perm],OptionsPattern[{m->momDefaults["m"]}]]:=momInverseBoundary[OptionValue[m]][perm]

momInverseBoundary::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momInverseBoundary::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
momInverseBoundary::badargsIn=messages["badargs"][perm,"a cell in the momentum amplituhedron"][2,0];
momInverseBoundary::badargsBound=messages["badargs"]["bound"]["m/2\[LessEqual]permK[perm]\[LessEqual]Length[perm]-m/2"];
momInverseBoundary[m_][perm_]:=(Message[momInverseBoundary::badargsM];$Failed)/;Not[MemberQ[{2,4},m]]
momInverseBoundary[m_][perm_]:=(Message[momInverseBoundary::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
momInverseBoundary[m_][perm_]:=(Message[momInverseBoundary::badargsBound];
$Failed)/;Not[m/2<=permK[perm]<=Length[perm]-m/2]
momInverseBoundary[m_][perm_]:=(Message[momInverseBoundary::badargsIn];$Failed)/;Not[MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm]]


(* ::Input::Initialization:: *)
momInterval[m_/;MemberQ[{2,4},m]][perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2]]:=(momInterval[m][perm1,perm2]=Intersection[posInterval[perm1,perm2],momStratification[m][topCell[Length[perm1],permK[perm1]]]])/;(Length[perm1]==Length[perm2]&&permK[perm1]==permK[perm2]&&(m/2<=permK[perm1]<=Length[perm1]-m/2)&&MemberQ[momStratification[m][topCell[Length[perm1],permK[perm1]]],perm1]&&MemberQ[momStratification[m][topCell[Length[perm2],permK[perm2]]],perm2])

momInterval[perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2],OptionsPattern[m->momDefaults["m"]]]:=momInterval[OptionValue[m]][perm1,perm2]

momInterval::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momInterval::badargsPerm1=messages["badargs"][perm1,"an affine permutation"][2,1];
momInterval::badargsPerm2=messages["badargs"][perm2,"an affine permutation"][2,2];
momInterval::badargsIn1=messages["badargs"][perm1,"a cell in the momentum amplituhedron"][2,1];
momInterval::badargsIn2=messages["badargs"][perm2,"a cell in the momentum amplituhedron"][2,2];
momInterval::badargsLength=messages["badargs"]["bound"]["Length[perm1]\[Equal]Length[perm2]"];
momInterval::badargsPermK=messages["badargs"]["bound"]["permK[perm1]\[Equal]permK[perm2]"];
momInterval::badargsBound1=messages["badargs"]["bound"]["(m/2\[LessEqual]permK[perm1]\[LessEqual]Length[perm1]-m/2)"];
momInterval[m_][perm1_,perm2_]:=(Message[momInterval::badargsM];$Failed)/;Not[m==2]
momInterval[m_][perm1_,perm2_]:=(Message[momInterval::badargsPerm1];$Failed)/;Not[legalListPermQ[perm1]]
momInterval[m_][perm1_,perm2_]:=(Message[momInterval::badargsPerm2];$Failed)/;Not[legalListPermQ[perm2]]
momInterval[m_][perm1_,perm2_]:=(Message[momInterval::badargsLength];$Failed)/;Not[Length[perm1]==Length[perm2]]
momInterval[m_][perm1_,perm2_]:=(Message[momInterval::badargsPermK];$Failed)/;Not[permK[perm1]==permK[perm2]]
momInterval[m_][perm1_,perm2_]:=(Message[momInterval::badargsBound1];$Failed)/;Not[(m/2<=permK[perm1]<=Length[perm1]-m/2)]
momInterval[m_][perm1_,perm2_]:=(Message[momInterval::badargsIn1];$Failed)/;Not[MemberQ[momStratification[m][topCell[Length[perm1],permK[perm1]]],perm1]]
momInterval[m_][perm1_,perm2_]:=(Message[momInterval::badargsIn2];$Failed)/;Not[MemberQ[momStratification[m][topCell[Length[perm2],permK[perm2]]],perm2]]



(* ::Input::Initialization:: *)
momPoset[m_/;MemberQ[{2,4},m]][perm_/;isTopCellQ[perm]]:=(momPoset[m][perm]=perm//momStratification[m]//Table[MemberQ[momStratification[m][#[[A1]]],#[[A2]]],{A1,#//Length},{A2,#//Length}]&//Boole//AdjacencyGraph//TransitiveReductionGraph//AdjacencyMatrix)

momPoset[m_/;MemberQ[{2,4},m]][perm_/;legalListPermQ[perm]]:=(momPoset[m][perm]=Block[{n=Length[perm],k=permK[perm],indices},indices=perm//momStratification[m]//Position[topCell[Length[perm],permK[perm]]//momStratification[m],#]&/@#&//Flatten;
topCell[Length[perm],permK[perm]]//momPoset[m]//#[[indices,indices]]&
])/;((m/2<=permK[perm]<=Length[perm]-m/2)&&MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm])

momPoset[m_/;MemberQ[{2,4},m]][perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2]]:=(momPoset[m][perm1,perm2]=Block[{n=Length[perm1],k=permK[perm1],indices},
indices=momInterval[m][perm1,perm2]//Position[topCell[n,k]//momStratification[m],#]&/@#&//Flatten;
topCell[n,k]//momPoset[m]//#[[indices,indices]]&
])/;(Length[perm1]==Length[perm2]&&permK[perm1]==permK[perm2]&&(m/2<=permK[perm1]<=Length[perm1]-m/2)&&MemberQ[momStratification[m][topCell[Length[perm1],permK[perm1]]],perm1]&&MemberQ[momStratification[m][topCell[Length[perm2],permK[perm2]]],perm2])

momPoset[perm_/;legalListPermQ[perm],OptionsPattern[{m->momDefaults["m"]}]]:=momPoset[OptionValue[m]][perm]
momPoset[perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2],OptionsPattern[m->momDefaults["m"]]]:=momPoset[OptionValue[m]][perm1,perm2]

momPoset::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momPoset::badargsPerm1=messages["badargs"][perm1,"an affine permutation"][2,1];
momPoset::badargsPerm2=messages["badargs"][perm2,"an affine permutation"][2,2];
momPoset::badargsIn1=messages["badargs"][perm1,"a cell in the momentum amplituhedron"][2,1];
momPoset::badargsIn2=messages["badargs"][perm2,"a cell in the momentum amplituhedron"][2,2];
momPoset::badargsLength=messages["badargs"]["bound"]["Length[perm1]\[Equal]Length[perm2]"];
momPoset::badargsPermK=messages["badargs"]["bound"]["permK[perm1]\[Equal]permK[perm2]"];
momPoset::badargsBound1=messages["badargs"]["bound"]["(m/2\[LessEqual]permK[perm1]\[LessEqual]Length[perm1]-m/2)"];
momPoset[m_][perm1_,perm2_]:=(Message[momPoset::badargsM];$Failed)/;Not[m==2]
momPoset[m_][perm1_,perm2_]:=(Message[momPoset::badargsPerm1];$Failed)/;Not[legalListPermQ[perm1]]
momPoset[m_][perm1_,perm2_]:=(Message[momPoset::badargsPerm2];$Failed)/;Not[legalListPermQ[perm2]]
momPoset[m_][perm1_,perm2_]:=(Message[momPoset::badargsLength];$Failed)/;Not[Length[perm1]==Length[perm2]]
momPoset[m_][perm1_,perm2_]:=(Message[momPoset::badargsPermK];$Failed)/;Not[permK[perm1]==permK[perm2]]
momPoset[m_][perm1_,perm2_]:=(Message[momPoset::badargsBound1];$Failed)/;Not[(m/2<=permK[perm1]<=Length[perm1]-m/2)]
momPoset[m_][perm1_,perm2_]:=(Message[momPoset::badargsIn1];$Failed)/;Not[MemberQ[momStratification[m][topCell[Length[perm1],permK[perm1]]],perm1]]
momPoset[m_][perm1_,perm2_]:=(Message[momPoset::badargsIn2];$Failed)/;Not[MemberQ[momStratification[m][topCell[Length[perm2],permK[perm2]]],perm2]]

momPoset::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
momPoset::badargsIn=messages["badargs"][perm,"a cell in the momentum amplituhedron"][2,0];
momPoset::badargsBound=messages["badargs"]["bound"]["(m/2\[LessEqual]permK[perm]\[LessEqual]Length[perm]-m/2)"];
momPoset[m_][perm_]:=(Message[momPoset::badargsM];$Failed)/;Not[m==2]
momPoset[m_][perm_]:=(Message[momPoset::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
momPoset[m_][perm_]:=(Message[momPoset::badargsIn];$Failed)/;Not[MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm]]
momPoset[m_][perm_]:=(Message[momPoset::badargsBound];$Failed)/;Not[(m/2<=permK[perm]<=Length[perm]-m/2)]


(* ::Input::Initialization:: *)
hypMap[perm_/;legalListPermQ[perm]]:=(hypMap[perm]=Block[{k=permK[perm],n=Length[perm],cmat=permToMat[perm],subsets,denom,num},
subsets=Range[n]//Subsets[#,{k}]&;
num=subsets//Det[cmat[[;;,#]]]Table[MemberQ[#,A1]//Boole,{A1,n}]&/@#&//Plus@@#&;
denom=subsets//Det[cmat[[;;,#]]]&/@#&//Plus@@#&;
num/denom
])/;(1<=permK[perm]<=Length[perm]-1)

hypMap::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
hypMap::badargsBound=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypMap[perm_]:=(Message[momMap::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
hypMap[perm_]:=(Message[momMap::badargsBound];$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]


(* ::Input::Initialization:: *)
hypDimensionCalc[perm_/;isTopCellQ[perm]]:=hypDimension[perm]=Length[perm]-1
hypDimensionCalc[perm_/;legalListPermQ[perm]&&posDimension[perm]==0]:=hypDimension[perm]=0
hypDimensionCalc[perm_/;legalListPermQ[perm]&&perm==Global`cyclicRep[perm]]:=hypDimension[perm]=Block[{dim},
dim=hypMap[perm]//Table[D[#,Global`\[Alpha][A1]],{A1,posDimension[perm]}]&//MatrixRank;
hypDimensionCalc[perm]=dim;
dim
]
hypDimensionCalc[perm_/;legalListPermQ[perm]]:=(hypDimension[perm]=hypDimensionCalc[Global`cyclicRep[perm]])

defineHypDimension[n_,k_]:=Block[{filename=dataFilename[hypDimension,n,k],depth,calc},
If[!FileExistsQ[filename],
depth=posStratificationSize[topCell[n,k]];Monitor[calc=topCell[n,k]//posStratification//Table[{{#[[hypDimensionB1]]},hypDimensionCalc[#[[hypDimensionB1]]]},{hypDimensionB1,#//Length}]&;,displayProgress[hypDimensionB1/depth]]];
If[$cachePrivate,calc//dataSave[hypDimension,n,k][#]&]
]

hypDimension::firstSave=messages["first"]["save"][n,k];
hypDimension::firstLoad=messages["first"]["load"][n,k];
hypDimension::firstFly=messages["first"]["fly"][n,k];
hypDimension[perm_/;legalListPermQ[perm]]:=Block[{k=permK[perm],n=Length[perm],filename},
filename=dataFilename[hypDimension,n,k];
If[FileExistsQ[filename],
Message[hypDimension::firstLoad,n,k,filename];
dataLoad[hypDimension,n,k];
hypDimension[perm],
If[$cachePrivate,
Message[hypDimension::firstSave,n,k,filename];
defineHypDimension[n,k];
hypDimension[perm],
Message[hypDimension::firstFly,n,k];
hypDimensionCalc[perm]
]
]
]/;(1<=permK[perm]<=Length[perm]-1)

hypDimension::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
hypDimension::badargsBound=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypDimension[perm_]:=(Message[hypDimension::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
hypDimension[perm_]:=(Message[hypDimension::badargsBound];$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]


(* ::Input::Initialization:: *)
hypBasis[perm_/;legalListPermQ[perm]]:=(hypBasis[perm]=Block[{cmat=permToMat[perm]},Select[Subsets[Range[Length[perm]],{permK[perm]}],Not[isZeroQ[Det[cmat[[;;,#]]]]]&]])/;(1<=permK[perm]<=Length[perm]-1)

hypBasis::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
hypBasis::badargsBound=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypBasis[perm_]:=(Message[hypBasis::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
hypBasis[perm_]:=(Message[hypBasis::badargsBound];$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]


(* ::Input::Initialization:: *)
defineHypBasisAll[n_,k_]:=Block[{filename=dataFilename[hypBasis,n,k],depth,calc},
If[!FileExistsQ[filename],
depth=posStratificationSize[topCell[n,k]];Monitor[calc=topCell[n,k]//posStratification//Table[{{#[[hypBasesB1]]},hypBasis[#[[hypBasesB1]]]},{hypBasesB1,#//Length}]&;,displayProgress[hypBasesB1/depth]]];
If[$cachePrivate,calc//dataSave[hypBasis,n,k][#]&];
calc[[;;,2]]
]

hypBases::firstSave=messages["first"]["save"][n,k];
hypBases::firstLoad=messages["first"]["load"][n,k];
hypBases::firstFly=messages["first"]["fly"][n,k];
hypBases[n_/;IntegerQ[n]&&n>0,k_/;IntegerQ[k]&&k>=0]:=(hypBases[n,k]=Block[{filename=dataFilename[hypBasis,n,k]},
If[FileExistsQ[filename],
Message[hypBases::firstLoad,n,k,filename];
dataLoad[hypBasis,n,k],
If[$cachePrivate,
Message[hypBases::firstSave,n,k,filename];,
Message[hypBases::firstFly,n,k];
];
defineHypBasisAll[n,k]
]
])/;(1<=k<=n-1)

hypBases::badargsN=messages["badargs"][n,"a positive integer"][0,1];
hypBases::badargsK=messages["badargs"][k,"a non-negative integer"][0,1];
hypBases::badargsBound=messages["badargs"]["bound"]["1\[LessEqual]k\[LessEqual]n-1"];
hypBases[n_,k_]:=(Message[hypBases::badargsN];$Failed)/;Not[IntegerQ[n]&&n>0]
hypBases[n_,k_]:=(Message[hypBases::badargsK];$Failed)/;Not[IntegerQ[k]&&k>=0]
hypBases[n_,k__]:=(Message[hypBases::badargsBound];$Failed)/;Not[(1<=k<=n-1)]


(* ::Input::Initialization:: *)
hypFaceQ[perm_/;legalListPermQ[perm]]:=(hypFaceQ[perm]=True)/;(Length[perm]-1==hypDimension[perm]&&permK[perm]//#(Length[perm]-#)==posDimension[perm]&)
hypFaceQ[perm_/;legalListPermQ[perm]]:=(hypFaceQ[perm]=Block[{hypDim=hypDimension[perm]},
posInverseBoundaries[1][perm]//Select[#,hypDimension[#]==hypDim&]&//Length[#]==0&
])/;(1<=permK[perm]<=Length[perm]-1)

hypFaceQ::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
hypFaceQ::badargsBound=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypFaceQ[perm_]:=(Message[hypFaceQ::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
hypFaceQ[perm_]:=(Message[hypFaceQ::badargsBound];$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]


(* ::Input::Initialization:: *)
hypFaces[perm_/;legalListPermQ[perm]]:=(hypFaces[perm]=posStratification[perm]//Select[#,hypFaceQ]&)/;(1<=permK[perm]<=Length[perm]-1)

hypFaces::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
hypFaces::badargsBound=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypFaces[perm_]:=(Message[hypFaces::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
hypFaces[perm_]:=(Message[hypFaces::badargsBound];$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]


(* ::Input::Initialization:: *)
hypBoundaries[0][perm_/;isTopCellQ[perm]]:=(hypBoundaries[0][perm]={perm})/;(1<=permK[perm]<=Length[perm]-1)
hypBoundaries[1][perm_/;isTopCellQ[perm]]:=(hypBoundaries[1][perm]=
hypFaces[perm]//Select[#,hypDimension[#]==Length[perm]-2&]&//Select[#,Length[Intersection[Simplify[hypMap[#]],{0,1}]]>=1&]&)/;(1<=permK[perm]<=Length[perm]-1)
hypBoundaries[codim_/;IntegerQ[codim]&&codim>1][perm_/;isTopCellQ[perm]]:=(hypBoundaries[codim][perm]=Block[{n=Length[perm],above},
above=hypBoundaries[codim-1][perm];
hypFaces[perm]//Select[#,hypDimension[#]==n-1 -codim&]&//Select[#,Length[Intersection[posInverseStratification[#],above]]>1&]&
])/;(1<=permK[perm]<=Length[perm]-1&&codim<=Length[perm]-1)

hypBoundaries::badargsCodim=messages["badargs"][codim,"a non-negative integer"][1,0];
hypBoundaries::badargsPerm=messages["badargs"][perm,"an affine permutation labelling a top-cell"][2,0];
hypBoundaries::badargsBound1=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypBoundaries::badargsBound2=messages["badargs"]["bound"]["codim\[LessEqual]Length[perm]-1"];
hypBoundaries[codim_][perm_]:=(Message[hypBoundaries::badargsCodim];$Failed)/;Not[IntegerQ[codim]&&codim>=0]
hypBoundaries[codim_][perm_]:=(Message[hypBoundaries::badargsPerm];$Failed)/;Not[isTopCellQ[perm]]
hypBoundaries[codim_][perm_]:=(Message[hypBoundaries::badargsBound1];$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]
hypBoundaries[codim_][perm_]:=(Message[hypBoundaries::badargsBound2];$Failed)/;Not[codim<=Length[perm]-1]


(* ::Input::Initialization:: *)
hypStratificationCalc[perm_/;isTopCellQ[perm]]:=(hypStratification[perm]=Block[{n=Length[perm],dim,boundaries},
dim =n-1;
boundaries=Monitor[Table[hypBoundaries[hypStratificationB1][perm],{hypStratificationB1,0,dim}]//Flatten[#,1]&,displayProgress[hypStratificationB1/dim]];
boundaries
])/;(1<=permK[perm]<=Length[perm]-1)

hypStratification::firstSave=messages["first"]["save"][n,k];
hypStratification::firstLoad=messages["first"]["load"][n,k];
hypStratification::firstFly=messages["first"]["fly"][n,k];
hypStratification[perm_/;isTopCellQ[perm]]:=Block[{k=permK[perm],n=Length[perm],filename},
filename=dataFilename[hypStratification,n,k];
If[FileExistsQ[filename],
Message[hypStratification::firstLoad,n,k,filename];
dataLoad[hypStratification,n,k];
hypStratification[perm],
hypDimension[perm];
If[$cachePrivate,
Message[hypStratification::firstSave,n,k,filename];{{{perm},hypStratificationCalc[perm]}}//dataSave[hypStratification,n,k][#]&;
hypStratification[perm],
Message[hypStratification::firstFly,n,k];
hypStratificationCalc[perm]
]]
]/;(1<=permK[perm]<=Length[perm]-1)

hypStratificationCalc[perm_/;legalListPermQ[perm]]:=(hypStratification[perm]=Intersection[posStratification[perm],hypStratification[topCell[Length[perm],permK[perm]]]])/;((1<=permK[perm]<=Length[perm]-1)&&MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm])
hypStratification[perm_/;legalListPermQ[perm]]:=hypStratificationCalc[perm]/;((1<=permK[perm]<=Length[perm]-1)&&MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm])

hypStratification::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
hypStratification::badargsIn=messages["badargs"][perm,"a cell in the hypersymplex"][0,0];
hypStratification::badargsBound=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypStratification[perm_]:=(Message[hypStratification::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
hypStratification[perm_]:=(Message[hypStratification::badargsBound];
$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]
hypStratification[perm_]:=(Message[hypStratification::badargsIn];$Failed)


(* ::Input::Initialization:: *)
hypInverseStratification[perm_/;legalListPermQ[perm]]:=(hypInverseStratification[perm]=Intersection[posInverseStratification[perm],hypStratification[topCell[Length[perm],permK[perm]]]])/;((1<=permK[perm]<=Length[perm]-1)&&MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm])

hypInverseStratification::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
hypInverseStratification::badargsIn=messages["badargs"][perm,"a cell in the hypersymplex"][0,0];
hypInverseStratification::badargsBound=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypInverseStratification[perm_]:=(Message[hypInverseStratification::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
hypInverseStratification[perm_]:=(Message[hypInverseStratification::badargsBound];
$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]
hypInverseStratification[perm_]:=(Message[hypInverseStratification::badargsIn];$Failed)/;Not[MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm]]


(* ::Input::Initialization:: *)
hypBoundary[perm_/;legalListPermQ[perm]]:=(hypBoundary[perm]=Select[hypStratification[perm],hypDimension[#]==hypDimension[perm]-1&])/;((1<=permK[perm]<=Length[perm]-1)&&MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm])

hypBoundary::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
hypBoundary::badargsIn=messages["badargs"][perm,"a cell in the hypersymplex"][0,0];
hypBoundary::badargsBound=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypBoundary[perm_]:=(Message[hypBoundary::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
hypBoundary[perm_]:=(Message[hypBoundary::badargsBound];
$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]
hypBoundary[perm_]:=(Message[hypBoundary::badargsIn];$Failed)/;Not[MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm]]


(* ::Input::Initialization:: *)
hypInverseBoundary[perm_/;legalListPermQ[perm]]:=(hypInverseBoundary[perm]=Select[hypInverseStratification[perm],hypDimension[#]==hypDimension[perm]+1&])/;((1<=permK[perm]<=Length[perm]-1)&&MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm])

hypInverseBoundary::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
hypInverseBoundary::badargsIn=messages["badargs"][perm,"a cell in the hypersymplex"][0,0];
hypInverseBoundary::badargsBound=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypInverseBoundary[perm_]:=(Message[hypInverseBoundary::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
hypInverseBoundary[perm_]:=(Message[hypInverseBoundary::badargsBound];
$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]
hypInverseBoundary[perm_]:=(Message[hypInverseBoundary::badargsIn];$Failed)/;Not[MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm]]


(* ::Input::Initialization:: *)
hypInterval[perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2]]:=(hypInterval[perm1,perm2]=Intersection[posInterval[perm1,perm2],hypStratification[topCell[Length[perm1],permK[perm1]]]])/;(Length[perm1]==Length[perm2]&&permK[perm1]==permK[perm2]&&(1<=permK[perm1]<=Length[perm1]-1)&&MemberQ[hypStratification[topCell[Length[perm1],permK[perm1]]],perm1]&&MemberQ[hypStratification[topCell[Length[perm2],permK[perm2]]],perm2])

hypInterval::badargsPerm1=messages["badargs"][perm1,"an affine permutation"][0,1];
hypInterval::badargsPerm2=messages["badargs"][perm2,"an affine permutation"][0,2];
hypInterval::badargsIn1=messages["badargs"][perm1,"a cell in the hypersimplex"][0,1];
hypInterval::badargsIn2=messages["badargs"][perm2,"a cell in the hypersimplex"][0,2];
hypInterval::badargsLength=messages["badargs"]["bound"]["Length[perm1]\[Equal]Length[perm2]"];
hypInterval::badargsPermK=messages["badargs"]["bound"]["permK[perm1]\[Equal]permK[perm2]"];
hypInterval::badargsBound1=messages["badargs"]["bound"]["1\[LessEqual]permK[perm1]\[LessEqual]Length[perm1]-1"];
hypInterval[perm1_,perm2_]:=(Message[hypInterval::badargsPerm1];$Failed)/;Not[legalListPermQ[perm1]]
hypInterval[perm1_,perm2_]:=(Message[hypInterval::badargsPerm2];$Failed)/;Not[legalListPermQ[perm2]]
hypInterval[perm1_,perm2_]:=(Message[hypInterval::badargsLength];$Failed)/;Not[Length[perm1]==Length[perm2]]
hypInterval[perm1_,perm2_]:=(Message[hypInterval::badargsPermK];$Failed)/;Not[permK[perm1]==permK[perm2]]
hypInterval[perm1_,perm2_]:=(Message[hypInterval::badargsBound1];$Failed)/;Not[1<=permK[perm1]<=Length[perm1]-1]
hypInterval[perm1_,perm2_]:=(Message[hypInterval::badargsIn1];$Failed)/;Not[MemberQ[hypStratification[topCell[Length[perm1],permK[perm1]]],perm1]]
hypInterval[perm1_,perm2_]:=(Message[hypInterval::badargsIn2];$Failed)/;Not[MemberQ[hypStratification[topCell[Length[perm2],permK[perm2]]],perm2]]



(* ::Input::Initialization:: *)
hypPoset[perm_/;isTopCellQ[perm]]:=(hypPoset[perm]=perm//hypStratification//Table[MemberQ[hypStratification[#[[A1]]],#[[A2]]],{A1,#//Length},{A2,#//Length}]&//Boole//AdjacencyGraph//TransitiveReductionGraph//AdjacencyMatrix)

hypPoset[perm_/;legalListPermQ[perm]]:=(hypPoset[perm]=Block[{n=Length[perm],k=permK[perm],indices},indices=perm//hypStratification//Position[topCell[Length[perm],permK[perm]]//hypStratification,#]&/@#&//Flatten;
topCell[n,k]//hypPoset//#[[indices,indices]]&
])/;((1<=permK[perm]<=Length[perm]-1)&&MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm])

hypPoset[perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2]]:=(hypPoset[perm1,perm2]=Block[{n=Length[perm1],k=permK[perm1],indices},
indices=hypInterval[perm1,perm2]//Position[topCell[n,k]//hypStratification,#]&/@#&//Flatten;
topCell[n,k]//hypPoset//#[[indices,indices]]&
])/;(Length[perm1]==Length[perm2]&&permK[perm1]==permK[perm2]&&(1<=permK[perm1]<=Length[perm1]-1)&&MemberQ[hypStratification[topCell[Length[perm1],permK[perm1]]],perm1]&&MemberQ[hypStratification[topCell[Length[perm2],permK[perm2]]],perm2])

hypPoset::badargsPerm1=messages["badargs"][perm1,"an affine permutation"][0,1];
hypPoset::badargsPerm2=messages["badargs"][perm2,"an affine permutation"][0,2];
hypPoset::badargsIn1=messages["badargs"][perm1,"a cell in the hypersimplex"][0,1];
hypPoset::badargsIn2=messages["badargs"][perm2,"a cell in the hypersimplex"][0,2];
hypPoset::badargsLength=messages["badargs"]["bound"]["Length[perm1]\[Equal]Length[perm2]"];
hypPoset::badargsPermK=messages["badargs"]["bound"]["permK[perm1]\[Equal]permK[perm2]"];
hypPoset::badargsBound1=messages["badargs"]["bound"]["1\[LessEqual]permK[perm1]\[LessEqual]Length[perm1]-1"];
hypPoset[perm1_,perm2_]:=(Message[hypPoset::badargsPerm1];$Failed)/;Not[legalListPermQ[perm1]]
hypPoset[perm1_,perm2_]:=(Message[hypPoset::badargsPerm2];$Failed)/;Not[legalListPermQ[perm2]]
hypPoset[perm1_,perm2_]:=(Message[hypPoset::badargsLength];$Failed)/;Not[Length[perm1]==Length[perm2]]
hypPoset[perm1_,perm2_]:=(Message[hypPoset::badargsPermK];$Failed)/;Not[permK[perm1]==permK[perm2]]
hypPoset[perm1_,perm2_]:=(Message[hypPoset::badargsBound1];$Failed)/;Not[1<=permK[perm1]<=Length[perm1]-1]
hypPoset[perm1_,perm2_]:=(Message[hypPoset::badargsIn1];$Failed)/;Not[MemberQ[hypStratification[topCell[Length[perm1],permK[perm1]]],perm1]]
hypPoset[perm1_,perm2_]:=(Message[hypPoset::badargsIn2];$Failed)/;Not[MemberQ[hypStratification[topCell[Length[perm2],permK[perm2]]],perm2]]

hypPoset::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,1];
hypPoset::badargsIn=messages["badargs"][perm,"a cell in the hypersimplex"][0,1];
hypPoset::badargsBound=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypPoset[perm_]:=(Message[hypPoset::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
hypPoset[perm_]:=(Message[hypPoset::badargsBound];$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]
hypPoset[perm_]:=(Message[hypPoset::badargsIn];$Failed)/;Not[MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm]]


(* ::Input::Initialization:: *)
adjacentPairs[list_/;ListQ[list]&&Length[list]>=2]:=Length[list]//Table[list[[{A1,Mod[A1,#]+1}]],{A1,#}]&


(* ::Input::Initialization:: *)
ampGeneralizedTrianglesCalc[2][n_/;IntegerQ[n]&&n>0,k_/;IntegerQ[k]&&k>=0]:=ampGeneralizedTriangles[2][n,k]=Block[{cache=$cachePrivate,output},
$cachePrivate=False;
output=posStratification[topCell[n,k]]//Select[#,posDimension[#]==2k&]&//Select[#,ampDimension[2,version->2][#]==2k&]&;
$cachePrivate=cache;
output
]

ampGeneralizedTrianglesCalc[4][n_/;IntegerQ[n]&&n>0,k_/;IntegerQ[k]&&k>=0]:=ampGeneralizedTriangles[4][n,k]=Block[{cache=$cachePrivate,output},
$cachePrivate=False;
output=posStratification[topCell[n,k]]//Select[#,(posDimension[#]==4k)&&(Global`intersectionNumber[#]==1)&]&//Select[#,ampDimension[4,version->2][#]==4k&]&;
$cachePrivate=cache;
output
]

ampGeneralizedTriangles::firstSave=messages["first"]["save"][n,k,m];
ampGeneralizedTriangles::firstLoad=messages["first"]["load"][n,k,m];
ampGeneralizedTriangles::firstFly=messages["first"]["fly"][n,k,m];
ampGeneralizedTriangles[m_/;MemberQ[{2,4},m]][n_/;IntegerQ[n]&&n>0,k_/;IntegerQ[k]&&k>=0]:=Block[{filename=dataFilename[ampGeneralizedTriangles,n,k,m]},
If[FileExistsQ[filename],
Message[ampGeneralizedTriangles::firstLoad,n,k,m,filename];
Get[filename][[1]]//(ampGeneralizedTriangles[Sequence@@#[[1,2]]][Sequence@@#[[1,1]]]=#[[2]])&;
ampGeneralizedTriangles[m][n,k],
If[$cachePrivate,
Message[ampGeneralizedTriangles::firstSave,n,k,m,filename];
{{{{n,k},{m}},ampGeneralizedTrianglesCalc[m][n,k]}}//dataSave[ampGeneralizedTriangles,n,k,m][#]&;
ampGeneralizedTriangles[m][n,k],
Message[ampGeneralizedTriangles::firstFly,n,k,m];
ampGeneralizedTrianglesCalc[m][n,k]
]
]
]/;(k+m<=n)

ampGeneralizedTriangles[n_,k_,OptionsPattern[{m->ampDefaults["m"]}]]:=ampGeneralizedTriangles[OptionValue[m]][n,k]

ampGeneralizedTriangles::badargsM=messages["badargs"][m,"2 or 4"][1,0];
ampGeneralizedTriangles::badargsN=messages["badargs"][n,"a positive integer"][2,1];
ampGeneralizedTriangles::badargsK=messages["badargs"][k,"a non-negative integer"][2,2];
ampGeneralizedTriangles::badargsBound=messages["badargs"]["bound"]["k+m\[LessEqual]n"];
ampGeneralizedTriangles[m_][n_,k_]:=(Message[ampGeneralizedTriangles::badargsM];$Failed)/;Not[MemberQ[{2,4},m]]
ampGeneralizedTriangles[m_][n_,k_]:=(Message[ampGeneralizedTriangles::badargsN];$Failed)/;Not[IntegerQ[n]&&n>0]
ampGeneralizedTriangles[m_][n_,k_]:=(Message[ampGeneralizedTriangles::badargsK];$Failed)/;Not[IntegerQ[k]&&k>=0]
ampGeneralizedTriangles[m_][n_,k_]:=(Message[ampGeneralizedTriangles::badargsBound];$Failed)/;Not[k+m<=n]


(* ::Input::Initialization:: *)
ampPattType[2][n_/;IntegerQ[n]&&n>0,k_/;IntegerQ[k]&&k>=0][l_/;IntegerQ[l]&&l>=0,p_/;IntegerQ[p]&&p>=0]:=(ampPattType[2][n,k][l,p]=Block[{range=Range[n],points,lines,ngons},
points=Subsets[Subsets[range,{1}],{p}];
lines=points//Complement[range,#//Flatten]&/@#&//adjacentPairs/@#&//Subsets[#,{l}]&/@#&;
ngons=Table[range,{k-p-l}];
Table[Table[Join[ngons,lines[[A1,A2]],points[[A1]]],{A2,lines[[A1]]//Length}],{A1,points//Length}]//Flatten[#,1]&
])/;(k+2<=n&&k-l-p>=0)
ampPattType[n_,k_,OptionsPattern[{m->ampDefaults["m"]}]][l_,p_]:=ampPattType[OptionValue[m]][n,k][l,p]

ampPattAll[2][n_/;IntegerQ[n]&&n>0,k_/;IntegerQ[k]&&k>=0]:=(ampPattAll[2][n,k]=Table[Table[ampPattType[2][n,k]@@{A2,A1},{A2,0,k-A1}],{A1,0,k}]//Flatten[#,2]&)/;(k+2<=n)
ampPattAll[n_,k_,OptionsPattern[{m->ampDefaults["m"]}]]:=ampPattAll[OptionValue[m]][n,k]


(* ::Input::Initialization:: *)
triSubgonQ[n_/;IntegerQ[n]&&n>=3,length_/;IntegerQ[length]&&length>0][arg_/;ListQ[arg]&&Length[arg]==Length[Union[arg]]]:=(triSubgonQ[n,length][arg]=True)/;(Length[arg]==length&&Length[Intersection[Range[n],arg]]==Length[arg]&&length<=n)

triSubgonQ[n_/;IntegerQ[n]&&n>=3][arg_/;ListQ[arg]&&Length[arg]==Length[Union[arg]]]:=(triSubgonQ[n][arg]=True)/;(Length[Intersection[Range[n],arg]]==Length[arg])

triSubgonQ[n_/;IntegerQ[n]&&n>=3,___][___]=False;


(* ::Input::Initialization:: *)
triLineSegIntQ[n_/;IntegerQ[n]&&n>=3][{pair1_,pair2_}]:=(triLineSegIntQ[n][{pair1,pair2}]=False)/;(({pair1,pair2}//triSubgonQ[n,2]/@#&//And@@#&)&&triSubgonQ[n,2][pair2]&&Length[Union[pair1,pair2]]<4)
triLineSegIntQ[n_/;IntegerQ[n]&&n>=3][{pair1_,pair2_}]:=(triLineSegIntQ[n][{pair1,pair2}]=Block[{verts,x,y,coords,denom,num},
verts=Join[pair1,pair2];
coords=Table[{Cos[2\[Pi] (A1-1)/n-\[Pi] (n-2)/(2n)],Sin[2\[Pi] (A1-1)/n-\[Pi] (n-2)/(2n)]},{A1,verts}];
denom=(Subscript[x, 3]-Subscript[x, 4]) (Subscript[y, 1]-Subscript[y, 2])-(Subscript[x, 1]-Subscript[x, 2]) (Subscript[y, 3]-Subscript[y, 4])//#/.Subscript[x, A1_]:>coords[[A1,1]]/.Subscript[y, A1_]:>coords[[A1,2]]&//FullSimplify;
If[denom==0,False,
num[1]=(Subscript[x, 3]-Subscript[x, 4]) (Subscript[y, 1]-Subscript[y, 3])-(Subscript[x, 1]-Subscript[x, 3]) (Subscript[y, 3]-Subscript[y, 4])//#/.Subscript[x, A1_]:>coords[[A1,1]]/.Subscript[y, A1_]:>coords[[A1,2]]&;
num[2]=(Subscript[x, 1]-Subscript[x, 2]) (Subscript[y, 1]-Subscript[y, 3])-(Subscript[x, 1]-Subscript[x, 3]) (Subscript[y, 1]-Subscript[y, 2])//#/.Subscript[x, A1_]:>coords[[A1,1]]/.Subscript[y, A1_]:>coords[[A1,2]]&;
0<=num[1]/denom<=1&&0<=num[2]/denom<=1
]])/;(({pair1,pair2}//triSubgonQ[n,2]/@#&//And@@#&)&&Length[Union[pair1,pair2]]==4)


(* ::Input::Initialization:: *)
triTriangleIntQ[n_/;IntegerQ[n]&&n>=3][{triple1_,triple2_}]:=(triTriangleIntQ[n][{triple1,triple2}]={triple1,triple2}//adjacentPairs/@#&//Table[{#[[1,A1]],#[[2,A2]]},{A1,3},{A2,3}]&//Flatten[#,1]&//triLineSegIntQ[n]/@#&//MemberQ[#,True]&)/;({triple1,triple2}//triSubgonQ[n,3]/@#&//And@@#&)
triTriangleIntQ[n_/;IntegerQ[n]&&n>=3][list_/;ListQ[list]&&Length[list]==1]:=(triTriangleIntQ[n][list]=False)/;(list//triSubgonQ[n,3]/@#&//And@@#&)
triTriangleIntQ[n_/;IntegerQ[n]&&n>=3][list_/;ListQ[list]&&Length[list]>=3]:=(triTriangleIntQ[n][list]=Subsets[list,{2}]//triTriangleIntQ[n]/@#&//And@@#&)/;(list//triSubgonQ[n,3]/@#&//And@@#&)


(* ::Input::Initialization:: *)
triCommonEdges[n_/;IntegerQ[n]&&n>=3][{tuple1_,tuple2_}]:=(Intersection[tuple1,tuple2]//If[Length[#]==2,{#},{}]&)/;({tuple1,tuple2}//triSubgonQ[n]/@#&//And@@#&)
triCommonEdges[n_/;IntegerQ[n]&&n>=3][list_/;ListQ[list]&&Length[list]==1]:=({})/;(triSubgonQ[n][Sequence@@list])
triCommonEdges[n_/;IntegerQ[n]&&n>=3][list_/;ListQ[list]&&Length[list]>=3]:=(Subsets[list,{2}]//triCommonEdges[n]/@#&//Union@@#&)/;(list//triSubgonQ[n]/@#&//And@@#&)


(* ::Input::Initialization:: *)
triGlueEdges[n_][list_][{}]:=list
triGlueEdges[n_/;IntegerQ[n]&&n>=3][list_/;ListQ[list]][edges_/;ListQ[edges]]:=Block[{glue},
glue=Select[list,SubsetQ[#,edges[[1]]]&];
triGlueEdges[n][Join[{glue//Union@@#&//Sort},Complement[list,glue]]][edges[[2;;]]]
]/;((list//triSubgonQ[n]/@#&//And@@#&)&&(edges//triSubgonQ[n,2]/@#&//And@@#&))


(* ::Input::Initialization:: *)
ampTriPattAll[2][n_/;IntegerQ[n]&&n>=3,0]:=ampTriPattAll[2][n,0]={{}}
ampTriPattAll[2][n_/;IntegerQ[n]&&n>=3,k_/;IntegerQ[k]&&k>0]:=(ampTriPattAll[2][n,k]={{Range[n]}})/;(k+2==n)
ampTriPattAll[2][n_/;IntegerQ[n]&&n>=3,k_/;IntegerQ[k]&&k>0]:=(ampTriPattAll[2][n,k]=Range[n]//Subsets[#,{3}]&//Subsets[#,{k}]&//Select[#,Not[triTriangleIntQ[n][#]]&]&//triGlueEdges[n][#][triCommonEdges[n][#]]&/@#&//Sort/@#&//Union//SortBy[#,Length[#]&]&)/;(k+2<n)
ampTriPattAll[n_,k_,OptionsPattern[{m->ampDefaults["m"]}]]:=ampTriPattAll[OptionValue[m]][n,k]


(* ::Input::Initialization:: *)
legalPattQ[n_/;IntegerQ[n]&&n>0][{args__}]:=(List[args]//ListQ/@#&//And@@#&)&&(List[args]//Length[Intersection[Range[n],#]]==Length[#]&/@#&//And@@#&)
legalPattQ[n_/;IntegerQ[n]&&n>0][__]:=False


(* ::Input::Initialization:: *)
ampPattToPerm[2][n_/;IntegerQ[n]&&n>0][patt_]:=(ampPattToPerm[2,n][patt]=Block[{x},Table[If[MemberQ[patt[[A1]],A2],Subscript[x, A1,A2],0],{A1,Length[patt]},{A2,n}]//matToPerm])/;(legalPattQ[n][patt]&&Length[patt]+2<=n)
ampPattToPerm[n_,OptionsPattern[{m->ampDefaults["m"]}]][patt_]:=ampPattToPerm[OptionValue[m]][n][patt]/;legalPattQ[n][patt]

ampPattToPerm::badargsM=messages["badargs"]["implemented"]["m\[Equal]2"];
ampPattToPerm::badargsN=messages["badargs"][n,"a positive integer"][2,0];
ampPattToPerm::badargsPatt=messages["badargs"]["patt"][3,0];
ampPattToPerm::badargsBound=messages["badargs"]["bound"]["Length[patt]+2\[LessEqual]n"];
ampPattToPerm[m_][n_][patt_]:=(Message[ampPattToPerm::badargsM];$Failed)/;Not[m==2]
ampPattToPerm[m_][n_][patt_]:=(Message[ampPattToPerm::badargsN];$Failed)/;Not[IntegerQ[n]&&n>0]
ampPattToPerm[m_][n_][patt_]:=(Message[ampPattToPerm::badargsPatt];$Failed)/;Not[legalPattQ[n][patt]]
ampPattToPerm[m_][n_][patt_]:=(Message[ampPattToPerm::badargsBound];$Failed)/;Not[Length[patt]+2<=n]


(* ::Input::Initialization:: *)
ampTriPattToPerm[2][n_/;IntegerQ[n]&&n>=3][patt_]:=(ampTriPattToPerm[2][n][patt]=Block[{x},patt//Table[Join[{#[[1]]},#[[A1;;A1+1]]],{A1,2,Length[#]-1}]&/@#&//Flatten[#,1]&//Table[If[MemberQ[#[[A1]],A2],Subscript[x, A1,A2],0],{A1,#//Length},{A2,n}]&//matrixToPerm])/;(legalPattQ[n][patt])
ampTriPattToPerm[n_,OptionsPattern[{m->ampDefaults["m"]}]][patt_]:=ampTriPattToPerm[OptionValue[m]][n][patt]/;(legalPattQ[n][patt])

ampTriPattToPerm::badargsM=messages["badargs"]["implemented"]["m\[Equal]2"];
ampTriPattToPerm::badargsN=messages["badargs"][n,"a positive integer greater than or equal to 3"][2,0];
ampTriPattToPerm::badargsPatt=messages["badargs"]["patt"][3,0];
ampTriPattToPerm[m_][n_][patt_]:=(Message[ampTriPattToPerm::badargsM];$Failed)/;Not[m==2]
ampTriPattToPerm[m_][n_][patt_]:=(Message[ampTriPattToPerm::badargsN];$Failed)/;Not[IntegerQ[n]&&n>=3]
ampTriPattToPerm[m_][n_][patt_]:=(Message[ampTriPattToPerm::badargsPatt];$Failed)/;Not[legalPattQ[n][patt]]


(* ::Input::Initialization:: *)
ampPermToPatt::firstSave=messages["first"]["save"][n,k,m];
ampPermToPatt::firstLoad=messages["first"]["load"][n,k,m];
ampPermToPatt::firstFly=messages["first"]["fly"][n,k,m];
ampPermToPatt[2][perm_/;legalListPermQ[perm]]:=Block[{n=Length[perm],k=permK[perm],filename,perms,patts,pattsToPerm,output},
filename=dataFilename[ampPermToPatt,n,k,2];
If[FileExistsQ[filename],
Message[ampPermToPatt::firstLoad,n,k,2,filename];
dataLoad[ampPermToPatt,n,k,2];,
perms=ampStratification[2][topCell[n,k]];
patts=ampPattAll[2][n,k];
pattsToPerm=patts//ampPattToPerm[2][n]/@#&;
If[Length[Union[pattsToPerm]]==Length[pattsToPerm]&&Length[pattsToPerm]==Length[perms],
output=Table[{{pattsToPerm[[A1]],2},ampPermToPatt[2][pattsToPerm[[A1]]]=patts[[A1]]},{A1,Length[patts]}],$Failed];
If[$cachePrivate,
Message[ampPermToPatt::firstSave,n,k,2,filename];
output//dataSave[ampPermToPatt,n,k,2][#]&;,
Message[ampPermToPatt::firstFly,n,k,2,filename];
]];
ampPermToPatt[2][perm]
]/;((permK[perm]+2<=Length[perm])&&MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm])

ampPermToPatt[perm_/;legalListPermQ[perm],OptionsPattern[{m->ampDefaults["m"]}]]:=ampPermToPatt[OptionValue[m]][perm]

ampPermToPatt::badargsM=messages["badargs"]["implemented"]["m\[Equal]2"];
ampPermToPatt::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampPermToPatt::badargsIn=messages["badargs"][perm,"a cell in the amplituhedron"][2,0];
ampPermToPatt::badargsBound=messages["badargs"]["bound"]["permK[perm]+2\[LessEqual]Length[perm]"];
ampPermToPatt[m_][perm_]:=(Message[ampPattToPerm::badargsM];$Failed)/;Not[m==2]
ampPermToPatt[m_][perm_]:=(Message[ampPattToPerm::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampPermToPatt[m_][perm_]:=(Message[ampPattToPerm::badargsIn];$Failed)/;Not[MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm]]
ampPermToPatt[m_][perm_]:=(Message[ampPattToPerm::badargsBound];$Failed)/;Not[permK[perm]+2<=Length[perm]]


(* ::Input::Initialization:: *)
ampPermToTriPatt::firstSave=messages["first"]["save"][n,k,m];
ampPermToTriPatt::firstLoad=messages["first"]["load"][n,k,m];
ampPermToTriPatt::firstFly=messages["first"]["fly"][n,k,m];
ampPermToTriPatt[2][perm_/;legalListPermQ[perm]]:=Block[{n=Length[perm],k=permK[perm],filename,perms,patts,pattsToPerm,output},
filename=dataFilename[ampPermToTriPatt,n,k,2];
If[FileExistsQ[filename],
Message[ampPermToTriPatt::firstLoad,n,k,2,filename];
dataLoad[ampPermToTriPatt,n,k,2];,
perms=ampGeneralizedTriangles[2][n,k];
patts=ampTriPattAll[2][n,k];
pattsToPerm=patts//ampTriPattToPerm[2][n]/@#&;
If[Length[Union[pattsToPerm]]==Length[pattsToPerm]&&Length[pattsToPerm]==Length[perms],
output=Table[{{pattsToPerm[[A1]],2},ampPermToTriPatt[2][pattsToPerm[[A1]]]=patts[[A1]]},{A1,Length[patts]}]//dataSave[ampPermToTriPatt,n,k,2][#]&;,$Failed];
If[$cachePrivate,
Message[ampPermToTriPatt::firstSave,n,k,2,filename];
output//dataSave[ampPermToTriPatt,n,k,2][#]&;,
Message[ampPermToTriPatt::firstFly,n,k,2,filename];
]];
ampPermToTriPatt[2][perm]
]/;((permK[perm]+2<=Length[perm])&&MemberQ[ampGeneralizedTriangles[2][Length[perm],permK[perm]],perm])

ampPermToTriPatt[perm_/;legalListPermQ[perm],OptionsPattern[{m->ampDefaults["m"]}]]:=ampPermToTriPatt[OptionValue[m]][perm]

ampPermToTriPatt::badargsM=messages["badargs"]["implemented"]["m\[Equal]2"];
ampPermToTriPatt::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampPermToTriPatt::badargsIn=messages["badargs"][perm,"a generalized triangle in the amplituhedron"][2,0];
ampPermToTriPatt::badargsBound=messages["badargs"]["bound"]["permK[perm]+2\[LessEqual]Length[perm]"];
ampPermToTriPatt[m_][perm_]:=(Message[ampPermToTriPatt::badargsM];$Failed)/;Not[m==2]
ampPermToTriPatt[m_][perm_]:=(Message[ampPermToTriPatt::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampPermToTriPatt[m_][perm_]:=(Message[ampPermToTriPatt::badargsIn];$Failed)/;Not[MemberQ[ampGeneralizedTriangles[2][Length[perm],permK[perm]],perm]]
ampPermToTriPatt[m_][perm_]:=(Message[ampPermToTriPatt::badargsBound];$Failed)/;Not[permK[perm]+2<=Length[perm]]


(* ::Input::Initialization:: *)
drawColour["Blue"]={0,0,205}//#/256&//RGBColor@@#&;
drawColour[True]=Lighter[drawColour["Blue"],0.8];
drawColour[False]=Darker[drawColour["Blue"],0.1];


(* ::Input::Initialization:: *)
drawDefaults["Image Size"]=80;
drawDefaults["Edge Thickness"]=0.05;
drawDefaults["Point Size"]=0.06;
drawDefaults["Permutation Magnification"]=1.3;
drawDefaults["Label Magnification"]=1.3;
drawDefaults["Label Buffer"]=0.25;
drawDefaults["Hasse Edge Thickness Scale Factor"]=1;


(* ::Input::Initialization:: *)
drawPosition[n_/;IntegerQ[n]&&n>0][i_/;IntegerQ[i]&&i>0]:={Cos[2\[Pi] (i-1)/n-\[Pi] (n-2)/(2n)],Sin[2\[Pi] (i-1)/n+-\[Pi](n-2)/(2n)]}/;(i<=n)


(* ::Input::Initialization:: *)
drawVertices[n_/;IntegerQ[n]&&n>0][vertices_]:=(vertices//drawPosition[n]/@#&)/;(triSubgonQ[n][vertices])


(* ::Input::Initialization:: *)
drawLabels[n_/;IntegerQ[n]&&n>0]["All"]:=Range[n]//ToString/@#&//MaTeX[#,Magnification->drawDefaults["Label Magnification"]]&/@#&
drawLabels[n_/;IntegerQ[n]&&n>0]["None"]:=Table[ToString[" "],{n}]//MaTeX[#,Magnification->drawDefaults["Label Magnification"]]&/@#&


(* ::Input::Initialization:: *)
Options[drawGraphic]={showLabels->False,isBackground->False,noLabelsResize->False,imageSize->drawDefaults["Image Size"]};

drawGraphic[n_/;IntegerQ[n]&&n>=3,OptionsPattern[]][point_]:=Block[{labels,origin,colour},
labels=If[OptionValue[showLabels],drawLabels[n]["All"],drawLabels[n]["None"]];
origin=Mean@drawVertices[n][Range[n]];
colour=drawColour[OptionValue[isBackground]];
If[OptionValue[noLabelsResize]&&!OptionValue[showLabels],
Graphics[{colour,PointSize[drawDefaults["Point Size"]],Point[drawVertices[n][point]]},ImageSize->OptionValue[imageSize]],
Graphics[{colour,PointSize[drawDefaults["Point Size"]],Point[drawVertices[n][point]],Text[#1,#2]&@@@({labels,((drawDefaults["Label Buffer"]+Norm[#-origin]) (Normalize[#-origin])+origin)&/@drawVertices[n][Range[n]]}\[Transpose])},ImageSize->OptionValue[imageSize]]]
]/;(triSubgonQ[n,1][point])

drawGraphic[n_/;IntegerQ[n]&&n>=3,OptionsPattern[]][line_]:=Block[{labels,origin,colour},
labels=If[OptionValue[showLabels],drawLabels[n]["All"],drawLabels[n]["None"]];
origin=Mean@drawVertices[n][Range[n]];
colour=drawColour[OptionValue[isBackground]];
If[OptionValue[noLabelsResize]&&!OptionValue[showLabels],
Graphics[{colour,Thickness->drawDefaults["Edge Thickness"],CapForm["Butt"],Line[drawVertices[n][line]]},ImageSize->OptionValue[imageSize]],
Graphics[{colour,Thickness->drawDefaults["Edge Thickness"],CapForm["Butt"],Line[drawVertices[n][line]],Text[#1,#2]&@@@({labels,((drawDefaults["Label Buffer"]+Norm[#-origin]) (Normalize[#-origin])+origin)&/@drawVertices[n][Range[n]]}\[Transpose])},ImageSize->OptionValue[imageSize]]]
]/;(triSubgonQ[n,2][line])

drawGraphic[n_/;IntegerQ[n]&&n>=3,OptionsPattern[]][tuple_]:=
Block[{vertices,labels,origin,colour},
vertices=drawVertices[n][tuple];
labels=If[OptionValue[showLabels],drawLabels[n]["All"],drawLabels[n]["None"]];
origin=Mean@drawVertices[n][Range[n]];
colour=drawColour[OptionValue[isBackground]];
If[OptionValue[noLabelsResize]&&!OptionValue[showLabels],
Graphics[{colour,Polygon[vertices]},ImageSize->OptionValue[imageSize]],
Graphics[{colour,Polygon[vertices],Text[#1,#2]&@@@({labels,((drawDefaults["Label Buffer"]+Norm[#-origin]) (Normalize[#-origin])+origin)&/@drawVertices[n][Range[n]]}\[Transpose])},ImageSize->OptionValue[imageSize]]
]
]/;(triSubgonQ[n][tuple]&&Length[tuple]>2)


(* ::Input::Initialization:: *)
Options[diagPattToGraphic]={m->2,showLabels->True,noLabelsResize->False,imageSize->drawDefaults["Image Size"]};
diagPattToGraphic[2,OptionsPattern[]][n_/;IntegerQ[n]&&n>=3][patt_]:=(patt//If[Length[#]==n,Graphics[],drawGraphic[n,noLabelsResize->OptionValue[noLabelsResize],showLabels->False,isBackground->False,imageSize->OptionValue[imageSize]][#]]&/@#&//Show[drawGraphic[n,showLabels->OptionValue[showLabels],noLabelsResize->OptionValue[noLabelsResize],isBackground->True,imageSize->OptionValue[imageSize]][Range[n]],Sequence[#]]&)/;(legalPattQ[n][patt])


(* ::Input::Initialization:: *)
Options[ampPermToGraphic]=Options[diagPattToGraphic];
ampPermToGraphic[2,options:OptionsPattern[]][perm_/;legalListPermQ[perm]]:=(perm//ampPermToPatt[2]//diagPattToGraphic[2,options][Length[perm]])/;(permK[perm]+2<=Length[perm]&&MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm])

ampPermToGraphic[2,options:OptionsPattern[]][perm_/;legalListPermQ[perm]]:=(perm//ampPermToTriPatt[2]//diagPattToGraphic[2,options][Length[perm]])/;(permK[perm]+2<=Length[perm]&&MemberQ[ampGeneralizedTriangles[2][Length[perm],permK[perm]],perm])

ampPermToGraphic[perm_/;legalListPermQ[perm],options:OptionsPattern[]]:=ampPermToGraphic[OptionValue[m],options][perm]

ampPermToGraphic::badargsM=messages["badargs"]["implemented"]["m\[Equal]2"];
ampPermToGraphic::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampPermToGraphic::badargsIn=messages["badargs"][perm,"a cell or a generalized triangle in the amplituhedron"][2,0];
ampPermToGraphic::badargsBound=messages["badargs"]["bound"]["permK[perm]+2\[LessEqual]Length[perm]"];
ampPermToGraphic[m_,___][perm_]:=(Message[ampPermToGraphic::badargsM];$Failed)/;Not[m==2]
ampPermToGraphic[m_,___][perm_]:=(Message[ampPermToGraphic::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampPermToGraphic[m_,___][perm_]:=(Message[ampPermToGraphic::badargsIn];$Failed)/;Not[MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm]||MemberQ[ampGeneralizedTriangles[2][Length[perm],permK[perm]],perm]]
ampPermToGraphic[m_,___][perm_]:=(Message[ampPermToGraphic::badargsBound];$Failed)/;Not[permK[perm]+2<=Length[perm]]


(* ::Input::Initialization:: *)
legalLeDiagramQ[lediagram_]:=(legalLeDiagramQ[lediagram]=lediagram//Normal//Position[#,"+"]&//Select[Tuples[#,2],#[[1,1]]<#[[2,1]]&&#[[1,2]]>#[[2,2]]&]&//Select[#,(lediagram//Normal)[[#[[2,1]],#[[1,2]]]]==="0"&]&//Length[#]==0&)/;(ListQ[Normal[lediagram]]&&Depth[Normal[lediagram]]==3&&(Normal[lediagram]//Flatten//Union//Intersection[#,{Null,"0","+"}]==#&))
legalLeDiagramQ[___]:=False


(* ::Input::Initialization:: *)
permToLeDiagram[perm_/;legalListPermQ[perm]]:=permToLeDiagram[perm]=Block[{nec=Global`necklace[perm],as,bs,pluses,young,zeros},
young=Table[If[i<j,{i,j},Null],{i,nec[[1]]},{j,ReverseSort[Complement[Range[Length[perm]],nec[[1]]]]}];
as=Table[ReverseSort[Complement[nec[[1]],nec[[i]]]],{i,2,Length[nec]}];
bs=Table[Complement[nec[[i]],nec[[1]]],{i,2,Length[nec]}];
pluses=Flatten[Table[Table[{as[[i,j]],bs[[i,j]]},{j,1,Length[as[[i]]]}],{i,1,Length[as]}],1]//DeleteDuplicates;
young=young/.Table[pluses[[i]]->"+",{i,1,Length[pluses]}];
young=young/.Flatten[Table[{i,j}->"0",{i,1,Length[perm]},{j,i+1,Length[perm]}],1];
Grid[young,Frame->{None,None,Flatten@Table[If[young[[i,j]]=!=Null,{i,j}->True],{i,Length[young]},{j,Length[Transpose[young]]}]},Alignment->{Center,Center}]]


(* ::Input::Initialization:: *)
leDiagramExtMatrix[lediagram_/;legalLeDiagramQ[lediagram]]:=Join[Join[#,{Null}]&/@(lediagram//Normal),{Table[Null,{i,1,Length[Transpose[lediagram//Normal]]+1}]}]


(* ::Input::Initialization:: *)
leDiagramPipeDreamStep[lediagram_/;legalLeDiagramQ[lediagram],edge_]:=Block[{elem,incoming},elem=(lediagram//Normal)[[edge[[2,1]],edge[[2,2]]]];incoming=edge[[2]]-edge[[1]];
Which[elem=="0",#+incoming&/@edge,elem==="+",{edge[[2]],edge[[2]]+Reverse[incoming]},elem==Null,edge]]


(* ::Input::Initialization:: *)
leDiagramPipeDream[lediagram_/;legalLeDiagramQ[lediagram],pos_]:=Block[{ext=leDiagramExtMatrix[lediagram]},
If[ext[[pos[[2,1]],pos[[2,2]]]]=!=Null,leDiagramPipeDream[lediagram,leDiagramPipeDreamStep[ext,pos]],pos]]


(* ::Input::Initialization:: *)
leDiagramLabels[lediagram_/;legalLeDiagramQ[lediagram]]:=Block[{boxesrows,boxescolumns,left,top},boxesrows=Count[#,Null]&/@(lediagram//Normal);boxescolumns=Reverse[Count[#,Null]&/@Transpose[lediagram//Normal]];
left=Table[i+boxesrows[[i]],{i,1,Length[lediagram//Normal]}];
top=Reverse[Table[Length[lediagram//Normal]+i-boxescolumns[[i]],{i,1,Length[Transpose[lediagram//Normal]]}]];
{left,top}]


(* ::Input::Initialization:: *)
leDiagramReadLabel[lediagram_/;legalLeDiagramQ[lediagram],final_]:=If[final[[2]]-final[[1]]=={1,0},leDiagramLabels[lediagram][[2,final[[1,2]]]],leDiagramLabels[lediagram][[1,final[[1,1]]]]]


(* ::Input::Initialization:: *)
leDiagramInitialConf[lediagram_/;legalLeDiagramQ[lediagram],label_]:=If[MemberQ[leDiagramLabels[lediagram][[1]],label],Tuples[{(Position[leDiagramLabels[lediagram][[1]],label]//Flatten),{0,1}}],Tuples[{{0,1},(Position[leDiagramLabels[lediagram][[2]],label]//Flatten)}]]


(* ::Input::Initialization:: *)
leDiagramFinalConf[lediagram_/;legalLeDiagramQ[lediagram],label_]:=leDiagramPipeDream[lediagram,leDiagramInitialConf[lediagram,label]]


(* ::Input::Initialization:: *)
leDiagramToPerm[lediagram_/;legalLeDiagramQ[lediagram]]:=leDiagramToPerm[lediagram]=Block[{n=lediagram//Normal//Length[#]+Length[#[[1]]]&,coloopReplacement},
coloopReplacement=leDiagramLabels[lediagram][[1]]//Select[#,leDiagramInitialConf[lediagram,#][[1,1]]-leDiagramFinalConf[lediagram,#][[2,1]]==0&]&//#->#+n&/@#&;InversePermutation[Table[leDiagramReadLabel[lediagram,leDiagramFinalConf[lediagram,i]],{i,1,Length[leDiagramLabels[lediagram]//Flatten]}]]//Global`decorate//#/.coloopReplacement&
]


(* ::Input::Initialization:: *)
leDiagramPrettify[lediagram_/;legalLeDiagramQ[lediagram]]:=leDiagramPrettify[lediagram]=
lediagram//Normal//Grid[Table[If[i==1&&j==Length[Transpose[#]]&&#[[i,j]]===Null,Item["",Frame->{{If[#[[i,j-1]]=!=Null,True,False],False},{False,True}},ItemSize->{1.5,1.5}],If[#[[i,j]]=!=Null,#[[i,j]],""]],{i,Length[#]},{j,Length[Transpose[#]]}],Dividers->{{1->True},{1->True}},Frame->{None,None,Flatten@Table[If[#[[i,j]]=!=Null,{i,j}->True],{i,Length[#]},{j,Length[Transpose[#]]}]},Alignment->{Center,Center},ItemSize->{1,1.5}]&//#/."+"->Style["+",FontSize->20,FontFamily->"CMUSerif-Roman"]/."0"->Style["0",FontSize->20,FontFamily->"CMUSerif-Roman"]&


(* ::Input::Initialization:: *)
leDiagramPrettifyReverse[lediagramPretty_]:=Block[{},lediagramPretty//Normal//{Length[#]+Length[#[[1]]],Length[#]}&//topCell@@#&//posStratification//permToLeDiagram/@#&//(leDiagramPrettifyReverse[leDiagramPrettify[#]]=#)&/@#&;
leDiagramPrettifyReverse[lediagramPretty]
]


(* ::Input::Initialization:: *)
posPermToLeDiagram[perm_/;legalListPermQ[perm]]:=posPermToLeDiagram[perm]=perm//permToLeDiagram//leDiagramPrettify

posPermToLeDiagram::badargsPerm=messages["badargs"][perm,"an affine permutation"][0,0];
posPermToLeDiagram[perm_]:=(Message[posPermToLeDiagram::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]


(* ::Input::Initialization:: *)
posLeDiagramToPerm[lediagramPretty_]:=posLeDiagramToPerm[lediagramPretty]=lediagramPretty//leDiagramPrettifyReverse//leDiagramToPerm


(* ::Input::Initialization:: *)
Options[ampStratificationToHasse]={m->ampDefaults["m"],showGraphics->True,showLabels->True,showPermutations->True,rasterize->True,imageResolution->Automatic,edgeScale->drawDefaults["Hasse Edge Thickness Scale Factor"]};

ampStratificationToHasse[2,options:OptionsPattern[]][perm_/;legalListPermQ[perm]]:=Block[{graphFinal,graphOriginal,graphPerm,graphLayers,graphCoordinates,imagesize,labels,n=Length[perm]},
graphOriginal=ampPoset[2][perm]//AdjacencyGraph//Graph[#,GraphLayout->"LayeredDigraphEmbedding"]&;
graphPerm=graphOriginal//GraphEmbedding//{#,SortBy[#,{#[[2]],#[[1]]}&]}&//FindPermutation@@#&//InversePermutation;
graphLayers=ampStratification[2][perm]//Table[Select[#,ampDimension[2][#]==A1&]//Length,{A1,0,2 permK[perm]}]&;
graphCoordinates=graphLayers//Table[Table[{(-(#[[A1]]+1)/2+A2)Max[#]/#[[A1]] ,1.5(A1-1)},{A2,#[[A1]]}],{A1,#//Length}]&//Flatten[#,1]&//Permute[#,graphPerm]&;
imagesize=If[OptionValue[showGraphics],100(1.5Max[graphLayers]-0.5),(10n+20)(1.5 Max[graphLayers]-0.5)];
labels=ampStratification[2][perm]//Table[A1->Placed[{
If[OptionValue[showPermutations],MaTeX["\{"<>ToString[#[[A1]]]<>"\}",Magnification->drawDefaults["Label Magnification"]]],
If[OptionValue[showGraphics],(#[[A1]]//ampPermToGraphic[2,showLabels->OptionValue[showLabels]])]},{Above,If[n==3,{{0,0},{-0.1,-0.15}},If[n==4,{{0,0},{-0.235,-0.115}},Center]]}],{A1,#//Length}]&;
graphFinal=Graph[graphOriginal,ImageSize->imagesize,
VertexCoordinates->graphCoordinates,
VertexLabels->labels,
VertexStyle->Directive[White,EdgeForm[{drawColour[False],Thickness[OptionValue[edgeScale]1.5/imagesize]}]],
VertexSize->If[OptionValue[showGraphics],0.65+If[n==4,0.18,0],0.1],
EdgeStyle->{Directive[Arrowheads[20/imagesize],drawColour[False],Thickness[OptionValue[edgeScale]1.5/imagesize]]}
];
If[OptionValue[rasterize],Rasterize[graphFinal,ImageSize->imagesize,ImageResolution->OptionValue[imageResolution]],graphFinal]
]/;((permK[perm]+2<=Length[perm])&&MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm])

ampStratificationToHasse[perm_/;legalListPermQ[perm],options:OptionsPattern[]]:=ampStratificationToHasse[OptionValue[m],options][perm]

ampStratificationToHasse::badargsM=messages["badargs"]["implemented"]["m\[Equal]2"];
ampStratificationToHasse::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampStratificationToHasse::badargsIn=messages["badargs"][perm,"a cell in the amplituhedron"][2,0];
ampStratificationToHasse::badargsBound=messages["badargs"]["bound"]["permK[perm]+2\[LessEqual]Length[perm]"];
ampStratificationToHasse[m_,___][perm_]:=(Message[ampStratificationToHasse::badargsM];$Failed)/;Not[m==2]
ampStratificationToHasse[m_,___][perm_]:=(Message[ampStratificationToHasse::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampStratificationToHasse[m_,___][perm_]:=(Message[ampStratificationToHasse::badargsIn];$Failed)/;Not[MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm]]
ampStratificationToHasse[m_,___][perm_]:=(Message[ampStratificationToHasse::badargsBound];$Failed)/;Not[permK[perm]+2<=Length[perm]]


(* ::Input::Initialization:: *)
Options[ampIntervalToHasse]=Options[ampStratificationToHasse];

ampIntervalToHasse[2,options:OptionsPattern[]][perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2]]:=Block[{graphFinal,graphOriginal,graphPerm,graphLayers,graphCoordinates,imagesize,labels,n=Length[perm1]},
graphOriginal=ampPoset[2][perm1,perm2]//AdjacencyGraph//Graph[#,GraphLayout->"LayeredDigraphEmbedding"]&;
graphPerm=graphOriginal//GraphEmbedding//{#,SortBy[#,{#[[2]],#[[1]]}&]}&//FindPermutation@@#&//InversePermutation;
graphLayers=ampInterval[2][perm1,perm2]//Table[Select[#,ampDimension[2][#]==A1&]//Length,{A1,0,2 permK[perm1]}]&;
graphCoordinates=graphLayers//Table[Table[{(-(#[[A1]]+1)/2+A2)Max[#]/#[[A1]] ,1.5(A1-1)},{A2,#[[A1]]}],{A1,#//Length}]&//Flatten[#,1]&//Permute[#,graphPerm]&;
imagesize=If[OptionValue[showGraphics],If[Max[graphLayers]==1,120,If[Max[graphLayers]==2,270,100(1.5Max[graphLayers]-0.5)]],(10n+20)(1.5 Max[graphLayers]-0.5)];
labels=ampInterval[2][perm1,perm2]//Table[A1->Placed[{
If[OptionValue[showPermutations],MaTeX["\{"<>ToString[#[[A1]]]<>"\}",Magnification->drawDefaults["Label Magnification"]]],
If[OptionValue[showGraphics],(#[[A1]]//ampPermToGraphic[2,showLabels->OptionValue[showLabels]])]},{Above,If[n==3,{{0,0},{-0.1,-0.15}},If[n==4,{{0,0},{-0.235,-0.115}},Center]]}],{A1,#//Length}]&;
graphFinal=Graph[graphOriginal,ImageSize->imagesize,
VertexCoordinates->graphCoordinates,
VertexLabels->labels,
VertexStyle->Directive[White,EdgeForm[{drawColour[False],Thickness[OptionValue[edgeScale]1.5/imagesize]}]],
VertexSize->If[OptionValue[showGraphics],0.65+If[n==4,0.2,0],0.1],
EdgeStyle->{Directive[Arrowheads[20/imagesize],drawColour[False],Thickness[OptionValue[edgeScale]1.5/imagesize]]}
];
If[OptionValue[rasterize],Rasterize[graphFinal,ImageSize->imagesize,ImageResolution->Automatic],graphFinal]
]/;(Length[perm1]==Length[perm2]&&permK[perm1]==permK[perm2]&&(permK[perm1]+2<=Length[perm1])&&MemberQ[ampStratification[2][topCell[Length[perm1],permK[perm1]]],perm1]&&MemberQ[ampStratification[2][topCell[Length[perm2],permK[perm2]]],perm2])

ampIntervalToHasse[perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2],options:OptionsPattern[]]:=ampIntervalToHasse[OptionValue[m],options][perm1,perm2]

ampIntervalToHasse::badargsM=messages["badargs"]["implemented"]["m\[Equal]2"];
ampIntervalToHasse::badargsPerm1=messages["badargs"][perm1,"an affine permutation"][2,1];
ampIntervalToHasse::badargsPerm2=messages["badargs"][perm2,"an affine permutation"][2,2];
ampIntervalToHasse::badargsIn1=messages["badargs"][perm1,"a cell in the amplituhedron"][2,1];
ampIntervalToHasse::badargsIn2=messages["badargs"][perm2,"a cell in the amplituhedron"][2,2];
ampIntervalToHasse::badargsLength=messages["badargs"]["bound"]["Length[perm1]\[Equal]Length[perm2]"];
ampIntervalToHasse::badargsPermK=messages["badargs"]["bound"]["permK[perm1]\[Equal]permK[perm2]"];
ampIntervalToHasse::badargsBound1=messages["badargs"]["bound"]["permK[perm1]+2\[LessEqual]Length[perm1]"];
ampIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[ampIntervalToHasse::badargsM];$Failed)/;Not[m==2]
ampIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[ampIntervalToHasse::badargsPerm1];$Failed)/;Not[legalListPermQ[perm1]]
ampIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[ampIntervalToHasse::badargsPerm2];$Failed)/;Not[legalListPermQ[perm2]]
ampIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[ampIntervalToHasse::badargsLength];$Failed)/;Not[Length[perm1]==Length[perm2]]
ampIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[ampIntervalToHasse::badargsPermK];$Failed)/;Not[permK[perm1]==permK[perm2]]
ampIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[ampIntervalToHasse::badargsBound1];$Failed)/;Not[permK[perm1]+2<=Length[perm1]]
ampIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[ampIntervalToHasse::badargsIn1];$Failed)/;Not[MemberQ[ampStratification[2][topCell[Length[perm1],permK[perm1]]],perm1]]
ampIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[ampIntervalToHasse::badargsIn2];$Failed)/;Not[MemberQ[ampStratification[2][topCell[Length[perm1],permK[perm2]]],perm2]]



(* ::Input::Initialization:: *)
Options[momStratificationToHasse]={m->momDefaults["m"],showGraphics->True,showPermutations->True,rasterize->True,imageResolution->Automatic,edgeScale->drawDefaults["Hasse Edge Thickness Scale Factor"]};

momStratificationToHasse[m_/;MemberQ[{2,4},m],options:OptionsPattern[]][perm_/;legalListPermQ[perm]]:=Block[{graphFinal,graphOriginal,graphPerm,graphLayers,graphCoordinates,imagesize,vertexsize,labels,k=permK[perm],n=Length[perm]},
graphOriginal=momPoset[m][perm]//AdjacencyGraph//Graph[#,GraphLayout->"LayeredDigraphEmbedding"]&;
graphPerm=graphOriginal//GraphEmbedding//{#,SortBy[#,{#[[2]],#[[1]]}&]}&//FindPermutation@@#&//InversePermutation;
graphLayers=momStratification[m][perm]//Table[Select[#,momDimension[m][#]==A1&]//Length,{A1,0,m/4(2n-m)}]&;
graphCoordinates=graphLayers//Table[Table[{(-(#[[A1]]+1)/2+A2)Max[#]/#[[A1]] ,1.5(A1-1)},{A2,#[[A1]]}],{A1,#//Length}]&//Flatten[#,1]&//Permute[#,graphPerm]&;
vertexsize=0.25+0.2Max[k,n-k];
imagesize=If[OptionValue[showGraphics],100(2 vertexsize Max[graphLayers]),(10n+20)(1.5 Max[graphLayers]-0.5)];
labels=momStratification[m][perm]//Table[A1->Placed[{
If[OptionValue[showPermutations],MaTeX["\{"<>ToString[#[[A1]]]<>"\}",Magnification->drawDefaults["Label Magnification"]]],
If[OptionValue[showGraphics],(#[[A1]]//posPermToLeDiagram)]},{Above,Center}],{A1,#//Length}]&;
graphFinal=Graph[graphOriginal,ImageSize->imagesize,
VertexCoordinates->graphCoordinates,
VertexLabels->labels,
VertexStyle->Directive[White,EdgeForm[{drawColour[False],Thickness[OptionValue[edgeScale]1.5/imagesize]}]],
VertexSize->If[OptionValue[showGraphics],0.5+If[k==n-k,0.2,0],0.1],
EdgeStyle->{Directive[Arrowheads[20/imagesize],drawColour[False],Thickness[OptionValue[edgeScale]1.5/imagesize]]}
];
If[OptionValue[rasterize],Rasterize[graphFinal,ImageSize->imagesize,ImageResolution->OptionValue[imageResolution]],graphFinal]
]/;((m/2<=permK[perm]<=Length[perm]-m/2)&&MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm])

momStratificationToHasse[perm_/;legalListPermQ[perm],options:OptionsPattern[]]:=momStratificationToHasse[OptionValue[m],options][perm]

momStratificationToHasse::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momStratificationToHasse::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
momStratificationToHasse::badargsIn=messages["badargs"][perm,"a cell in the momentum amplituhedron"][2,0];
momStratificationToHasse::badargsBound=messages["badargs"]["bound"]["m/2\[LessEqual]permK[perm]\[LessEqual]Length[perm]-m/2"];
momStratificationToHasse[m_,___][perm_]:=(Message[momStratificationToHasse::badargsM];$Failed)/;Not[MemberQ[{2,4},m]]
momStratificationToHasse[m_,___][perm_]:=(Message[momStratificationToHasse::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
momStratificationToHasse[m_,___][perm_]:=(Message[momStratificationToHasse::badargsIn];$Failed)/;Not[MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm]]
momStratificationToHasse[m_,___][perm_]:=(Message[momStratificationToHasse::badargsBound];$Failed)/;Not[m/2<=permK[perm]<=Length[perm]-m/2]


(* ::Input::Initialization:: *)
Options[momIntervalToHasse]=Options[momStratificationToHasse];

momIntervalToHasse[m_/;MemberQ[{2,4},m],options:OptionsPattern[]][perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2]]:=Block[{graphFinal,graphOriginal,graphPerm,graphLayers,graphCoordinates,imagesize,vertexsize,labels,k=permK[perm1],n=Length[perm1]},
graphOriginal=momPoset[m][perm1,perm2]//AdjacencyGraph//Graph[#,GraphLayout->"LayeredDigraphEmbedding"]&;
graphPerm=graphOriginal//GraphEmbedding//{#,SortBy[#,{#[[2]],#[[1]]}&]}&//FindPermutation@@#&//InversePermutation;
graphLayers=momInterval[m][perm1,perm2]//Table[Select[#,momDimension[m][#]==A1&]//Length,{A1,0,m/4(2n-m)}]&;
graphCoordinates=graphLayers//Table[Table[{(-(#[[A1]]+1)/2+A2)Max[#]/#[[A1]] ,1.5(A1-1)},{A2,#[[A1]]}],{A1,#//Length}]&//Flatten[#,1]&//Permute[#,graphPerm]&;
vertexsize=0.25+0.2Max[k,n-k];
imagesize=If[OptionValue[showGraphics],100(2 vertexsize Max[graphLayers]),(10n+20)(1.5 Max[graphLayers]-0.5)];
labels=momInterval[m][perm1,perm2]//Table[A1->Placed[{
If[OptionValue[showPermutations],MaTeX["\{"<>ToString[#[[A1]]]<>"\}",Magnification->drawDefaults["Label Magnification"]]],
If[OptionValue[showGraphics],(#[[A1]]//posPermToLeDiagram)]},{Above,Center}],{A1,#//Length}]&;
graphFinal=Graph[graphOriginal,ImageSize->imagesize,
VertexCoordinates->graphCoordinates,
VertexLabels->labels,
VertexStyle->Directive[White,EdgeForm[{drawColour[False],Thickness[OptionValue[edgeScale]1.5/imagesize]}]],
VertexSize->If[OptionValue[showGraphics],0.5+If[k==n-k,0.2,0],0.1],
EdgeStyle->{Directive[Arrowheads[20/imagesize],drawColour[False],Thickness[OptionValue[edgeScale]1.5/imagesize]]}
];
If[OptionValue[rasterize],Rasterize[graphFinal,ImageSize->imagesize,ImageResolution->OptionValue[imageResolution]],graphFinal]
]/;(Length[perm1]==Length[perm2]&&permK[perm1]==permK[perm2]&&(m/2<=permK[perm1]<=Length[perm1]-m/2)&&MemberQ[momStratification[m][topCell[Length[perm1],permK[perm1]]],perm1]&&MemberQ[momStratification[m][topCell[Length[perm2],permK[perm2]]],perm2])

momIntervalToHasse[perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2],options:OptionsPattern[]]:=momIntervalToHasse[OptionValue[m],options][perm1,perm2]

momIntervalToHasse::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momIntervalToHasse::badargsPerm1=messages["badargs"][perm1,"an affine permutation"][2,1];
momIntervalToHasse::badargsPerm2=messages["badargs"][perm2,"an affine permutation"][2,2];
momIntervalToHasse::badargsIn1=messages["badargs"][perm1,"a cell in the momentum amplituhedron"][2,1];
momIntervalToHasse::badargsIn2=messages["badargs"][perm2,"a cell in the momentum amplituhedron"][2,2];
momIntervalToHasse::badargsLength=messages["badargs"]["bound"]["Length[perm1]\[Equal]Length[perm2]"];
momIntervalToHasse::badargsPermK=messages["badargs"]["bound"]["permK[perm1]\[Equal]permK[perm2]"];
momIntervalToHasse::badargsBound1=messages["badargs"]["bound"]["(m/2\[LessEqual]permK[perm1]\[LessEqual]Length[perm1]-m/2)"];
momIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[momIntervalToHasse::badargsM];$Failed)/;Not[m==2]
momIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[momIntervalToHasse::badargsPerm1];$Failed)/;Not[legalListPermQ[perm1]]
momIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[momIntervalToHasse::badargsPerm2];$Failed)/;Not[legalListPermQ[perm2]]
momIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[momIntervalToHasse::badargsLength];$Failed)/;Not[Length[perm1]==Length[perm2]]
momIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[momIntervalToHasse::badargsPermK];$Failed)/;Not[permK[perm1]==permK[perm2]]
momIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[momIntervalToHasse::badargsBound1];$Failed)/;Not[(m/2<=permK[perm1]<=Length[perm1]-m/2)]
momIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[momIntervalToHasse::badargsIn1];$Failed)/;Not[MemberQ[momStratification[m][topCell[Length[perm1],permK[perm1]]],perm1]]
momIntervalToHasse[m_,___][perm1_,perm2_]:=(Message[momIntervalToHasse::badargsIn2];$Failed)/;Not[MemberQ[momStratification[m][topCell[Length[perm2],permK[perm2]]],perm2]]



(* ::Input::Initialization:: *)
Options[hypStratificationToHasse]={showGraphics->True,showPermutations->True,rasterize->True,imageResolution->Automatic, edgeScale->drawDefaults["Hasse Edge Thickness Scale Factor"]};

hypStratificationToHasse[perm_/;legalListPermQ[perm],options:OptionsPattern[]]:=Block[{graphFinal,graphOriginal,graphPerm,graphLayers,graphCoordinates,imagesize,vertexsize,labels,k=permK[perm],n=Length[perm]},
graphOriginal=hypPoset[perm]//AdjacencyGraph//Graph[#,GraphLayout->"LayeredDigraphEmbedding"]&;
graphPerm=graphOriginal//GraphEmbedding//{#,SortBy[#,{#[[2]],#[[1]]}&]}&//FindPermutation@@#&//InversePermutation;
graphLayers=hypStratification[perm]//Table[Select[#,hypDimension[#]==A1&]//Length,{A1,0,n-1}]&;
graphCoordinates=graphLayers//Table[Table[{(-(#[[A1]]+1)/2+A2)Max[#]/#[[A1]] ,1.5(A1-1)},{A2,#[[A1]]}],{A1,#//Length}]&//Flatten[#,1]&//Permute[#,graphPerm]&;
vertexsize=0.25+0.2Max[k,n-k];
imagesize=If[OptionValue[showGraphics],100(2 vertexsize Max[graphLayers]),(10n+20)(1.5 Max[graphLayers]-0.5)];
labels=hypStratification[perm]//Table[A1->Placed[{
If[OptionValue[showPermutations],MaTeX["\{"<>ToString[#[[A1]]]<>"\}",Magnification->drawDefaults["Label Magnification"]]],
If[OptionValue[showGraphics],(#[[A1]]//posPermToLeDiagram)]},{Above,Center}],{A1,#//Length}]&;
graphFinal=Graph[graphOriginal,ImageSize->imagesize,
VertexCoordinates->graphCoordinates,
VertexLabels->labels,
VertexStyle->Directive[White,EdgeForm[{drawColour[False],Thickness[OptionValue[edgeScale]1.5/imagesize]}]],
VertexSize->If[OptionValue[showGraphics],0.5+If[k==n-k,0.2,0],0.1],
EdgeStyle->{Directive[Arrowheads[20/imagesize],drawColour[False],Thickness[OptionValue[edgeScale]1.5/imagesize]]}
];
If[OptionValue[rasterize],Rasterize[graphFinal,ImageSize->imagesize,ImageResolution->OptionValue[imageResolution]],graphFinal]
]/;((1<=permK[perm]<=Length[perm]-1)&&MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm])

hypStratificationToHasse::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
hypStratificationToHasse::badargsIn=messages["badargs"][perm,"a cell in the hypersimplex"][2,0];
hypStratificationToHasse::badargsBound=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypStratificationToHasse[perm_,___]:=(Message[hypStratificationToHasse::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
hypStratificationToHasse[perm_,___]:=(Message[hypStratificationToHasse::badargsIn];$Failed)/;Not[MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm]]
hypStratificationToHasse[perm_,___]:=(Message[hypStratificationToHasse::badargsBound];$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]


(* ::Input::Initialization:: *)
Options[hypIntervalToHasse]=Options[hypStratificationToHasse];

hypIntervalToHasse[perm1_/;legalListPermQ[perm1],perm2_/;legalListPermQ[perm2],options:OptionsPattern[]]:=Block[{graphFinal,graphOriginal,graphPerm,graphLayers,graphCoordinates,imagesize,vertexsize,labels,k=permK[perm1],n=Length[perm1]},
graphOriginal=hypPoset[perm1,perm2]//AdjacencyGraph//Graph[#,GraphLayout->"LayeredDigraphEmbedding"]&;
graphPerm=graphOriginal//GraphEmbedding//{#,SortBy[#,{#[[2]],#[[1]]}&]}&//FindPermutation@@#&//InversePermutation;
graphLayers=hypInterval[perm1,perm2]//Table[Select[#,hypDimension[#]==A1&]//Length,{A1,0,n-1}]&;
graphCoordinates=graphLayers//Table[Table[{(-(#[[A1]]+1)/2+A2)Max[#]/#[[A1]] ,1.5(A1-1)},{A2,#[[A1]]}],{A1,#//Length}]&//Flatten[#,1]&//Permute[#,graphPerm]&;
vertexsize=0.25+0.2Max[k,n-k];
imagesize=If[OptionValue[showGraphics],100(2 vertexsize Max[graphLayers]),(10n+20)(1.5 Max[graphLayers]-0.5)];
labels=hypInterval[perm1,perm2]//Table[A1->Placed[{
If[OptionValue[showPermutations],MaTeX["\{"<>ToString[#[[A1]]]<>"\}",Magnification->drawDefaults["Label Magnification"]]],
If[OptionValue[showGraphics],(#[[A1]]//posPermToLeDiagram)]},{Above,Center}],{A1,#//Length}]&;
graphFinal=Graph[graphOriginal,ImageSize->imagesize,
VertexCoordinates->graphCoordinates,
VertexLabels->labels,
VertexStyle->Directive[White,EdgeForm[{drawColour[False],Thickness[OptionValue[edgeScale]1.5/imagesize]}]],
VertexSize->If[OptionValue[showGraphics],0.5+If[k==n-k,0.2,0],0.1],
EdgeStyle->{Directive[Arrowheads[20/imagesize],drawColour[False],Thickness[OptionValue[edgeScale]1.5/imagesize]]}
];
If[OptionValue[rasterize],Rasterize[graphFinal,ImageSize->imagesize,ImageResolution->OptionValue[imageResolution]],graphFinal]
]/;(Length[perm1]==Length[perm2]&&permK[perm1]==permK[perm2]&&(1<=permK[perm1]<=Length[perm1]-1)&&MemberQ[hypStratification[topCell[Length[perm1],permK[perm1]]],perm1]&&MemberQ[hypStratification[topCell[Length[perm2],permK[perm2]]],perm2])

hypIntervalToHasse::badargsPerm1=messages["badargs"][perm1,"an affine permutation"][0,1];
hypIntervalToHasse::badargsPerm2=messages["badargs"][perm2,"an affine permutation"][0,2];
hypIntervalToHasse::badargsIn1=messages["badargs"][perm1,"a cell in the hypersimplex"][0,1];
hypIntervalToHasse::badargsIn2=messages["badargs"][perm2,"a cell in the hypersimplex"][0,2];
hypIntervalToHasse::badargsLength=messages["badargs"]["bound"]["Length[perm1]\[Equal]Length[perm2]"];
hypIntervalToHasse::badargsPermK=messages["badargs"]["bound"]["permK[perm1]\[Equal]permK[perm2]"];
hypIntervalToHasse::badargsBound1=messages["badargs"]["bound"]["1\[LessEqual]permK[perm1]\[LessEqual]Length[perm1]-1"];
hypIntervalToHasse[perm1_,perm2_,___]:=(Message[hypIntervalToHasse::badargsPerm1];$Failed)/;Not[legalListPermQ[perm1]]
hypIntervalToHasse[perm1_,perm2_,___]:=(Message[hypIntervalToHasse::badargsPerm2];$Failed)/;Not[legalListPermQ[perm2]]
hypIntervalToHasse[perm1_,perm2_,___]:=(Message[hypIntervalToHasse::badargsLength];$Failed)/;Not[Length[perm1]==Length[perm2]]
hypIntervalToHasse[perm1_,perm2_,___]:=(Message[hypIntervalToHasse::badargsPermK];$Failed)/;Not[permK[perm1]==permK[perm2]]
hypIntervalToHasse[perm1_,perm2_,___]:=(Message[hypIntervalToHasse::badargsBound1];$Failed)/;Not[1<=permK[perm1]<=Length[perm1]-1]
hypIntervalToHasse[perm1_,perm2_,___]:=(Message[hypIntervalToHasse::badargsIn1];$Failed)/;Not[MemberQ[hypStratification[topCell[Length[perm1],permK[perm1]]],perm1]]
hypIntervalToHasse[perm1_,perm2_,___]:=(Message[hypIntervalToHasse::badargsIn2];$Failed)/;Not[MemberQ[hypStratification[topCell[Length[perm2],permK[perm2]]],perm2]]



(* ::Input::Initialization:: *)
Options[ampStratificationTo3D]={m->ampDefaults["m"],showGraphics->False,showLabels->False,showPermutations->True,imageSize->0.5drawDefaults["Image Size"]};

ampStratificationTo3D[2,options:OptionsPattern[]][perm_/;legalListPermQ[perm]]:=(Block[{points,pointsAll,graph,labels},
points=perm//ampStratification[2]//Select[#,ampDimension[2][#]==0&]&;
pointsAll=ampStratification[2][topCell[Length[perm],permK[perm]]]//Select[#,ampDimension[2][#]==0&]&;
graph=points//Table[A1!=A2&&(Intersection[ampInverseStratification[2][#[[A1]]],ampInverseStratification[2][#[[A2]]]]//Select[#,ampDimension[2][#]==1&]&//Length[#]>0&),{A1,#//Length},{A2,#//Length}]&//Boole//GraphPlot3D[#,EdgeRenderingFunction->({drawColour[True],Cylinder[#1,.02]}&),VertexRenderingFunction->({EdgeForm[Black],{Black,Style[Text[Position[pointsAll,points[[#2]]][[1,1]],#1],FontSize->14,FontFamily->"Utopia"]},{drawColour[True],Sphere[#,0.18]}}&),VertexLabeling->All,ImageSize->250]&;
If[Not[OptionValue[showGraphics]]&& Not[OptionValue[showPermutations]],graph,
labels=points//Table[{ToString[Position[pointsAll,points[[A1]]][[1,1]]],"\[Rule]",If[OptionValue[showPermutations],ToString[#[[A1]]]],If[OptionValue[showGraphics],ampPermToGraphic[2,showLabels->OptionValue[showLabels],imageSize->OptionValue[imageSize]][#[[A1]]]]},{A1,#//Length}]&//Grid[#,Alignment->Left]&;
If[OptionValue[showGraphics],Grid[{{graph},{labels}}],Grid[{{graph,labels}}]]]
])/;((permK[perm]+2<=Length[perm])&&MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm]&&(1<=ampDimension[2][perm]<=3))

ampStratificationTo3D[perm_/;legalListPermQ[perm],options:OptionsPattern[]]:=ampStratificationTo3D[2,options][perm]

ampStratificationTo3D::badargsM=messages["badargs"]["implemented"]["m\[Equal]2"];
ampStratificationTo3D::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampStratificationTo3D::badargsIn=messages["badargs"][perm,"a cell in the amplituhedron"][2,0];
ampStratificationTo3D::badargsBound1=messages["badargs"]["bound"]["permK[perm]+2\[LessEqual]Length[perm]"];
ampStratificationTo3D::badargsBound2=messages["badargs"]["bound"]["1\[LessEqual]ampDimension[2][perm]\[LessEqual]3"];
ampStratificationTo3D[m_,___][perm_]:=(Message[ampStratificationTo3D::badargsM];$Failed)/;Not[m==2]
ampStratificationTo3D[m_,___][perm_]:=(Message[ampStratificationTo3D::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampStratificationTo3D[m_,___][perm_]:=(Message[ampStratificationTo3D::badargsIn];$Failed)/;Not[MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm]]
ampStratificationTo3D[m_,___][perm_]:=(Message[ampStratificationTo3D::badargsBound1];$Failed)/;Not[permK[perm]+2<=Length[perm]]
ampStratificationTo3D[m_,___][perm_]:=(Message[ampStratificationTo3D::badargsBound2];$Failed)/;Not[1<=ampDimension[2][perm]<=3]


(* ::Input::Initialization:: *)
Options[momStratificationTo3D]={m->momDefaults["m"],showGraphics->False,showPermutations->True};

momStratificationTo3D[m_/;MemberQ[{2,4},m],options:OptionsPattern[]][perm_/;legalListPermQ[perm]]:=(Block[{points,pointsAll,graph,labels},
points=perm//momStratification[m]//Select[#,momDimension[m][#]==0&]&;
pointsAll=momStratification[m][topCell[Length[perm],permK[perm]]]//Select[#,momDimension[m][#]==0&]&;
graph=points//Table[A1!=A2&&(Intersection[momInverseStratification[m][#[[A1]]],momInverseStratification[m][#[[A2]]]]//Select[#,momDimension[m][#]==1&]&//Length[#]>0&),{A1,#//Length},{A2,#//Length}]&//Boole//GraphPlot3D[#,EdgeRenderingFunction->({drawColour[True],Cylinder[#1,.02]}&),VertexRenderingFunction->({EdgeForm[Black],{Black,Style[Text[Position[pointsAll,points[[#2]]][[1,1]],#1],FontSize->14,FontFamily->"Utopia"]},{drawColour[True],Sphere[#,0.18]}}&),VertexLabeling->All,ImageSize->250]&;
If[Not[OptionValue[showGraphics]]&& Not[OptionValue[showPermutations]],graph,
labels=points//Table[{ToString[Position[pointsAll,points[[A1]]][[1,1]]],"\[Rule]",If[OptionValue[showPermutations],ToString[#[[A1]]]],If[OptionValue[showGraphics],posPermToLeDiagram[#[[A1]]]]},{A1,#//Length}]&//Grid[#,Alignment->Left]&;
If[OptionValue[showGraphics],Grid[{{graph},{labels}}],Grid[{{graph,labels}}]]]
])/;((m/2<=permK[perm]<=m/4(2Length[perm]-m))&&MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm]&&(1<=momDimension[m][perm]<=3))

momStratificationTo3D[perm_/;legalListPermQ[perm],options:OptionsPattern[]]:=momStratificationTo3D[OptionValue[m],options][perm]

momStratificationTo3D::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momStratificationTo3D::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
momStratificationTo3D::badargsIn=messages["badargs"][perm,"a cell in the momentum amplituhedron"][2,0];
momStratificationTo3D::badargsBound1=messages["badargs"]["bound"]["m/2\[LessEqual]permK[perm]\[LessEqual]Length[perm]-m/2"];
momStratificationTo3D::badargsBound2=messages["badargs"]["bound"]["1\[LessEqual]momDimension[m][perm]\[LessEqual]3"];
momStratificationTo3D[m_,___][perm_]:=(Message[momStratificationTo3D::badargsM];$Failed)/;Not[MemberQ[{2,4},m]]
momStratificationTo3D[m_,___][perm_]:=(Message[momStratificationTo3D::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
momStratificationTo3D[m_,___][perm_]:=(Message[momStratificationTo3D::badargsIn];$Failed)/;Not[MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm]]
momStratificationTo3D[m_,___][perm_]:=(Message[momStratificationTo3D::badargsBound1];$Failed)/;Not[m/2<=permK[perm]<=Length[perm]-m/2]
momStratificationTo3D[m_,___][perm_]:=(Message[momStratificationTo3D::badargsBound2];$Failed)/;Not[1<=momDimension[m][perm]<=3]


(* ::Input::Initialization:: *)
Options[hypStratificationTo3D]={showPermutations->True,showGraphics->False};

hypStratificationTo3D[perm_/;legalListPermQ[perm],options:OptionsPattern[]]:=(Block[{points,pointsAll,graph,labels},
points=perm//hypStratification//Select[#,hypDimension[#]==0&]&;
pointsAll=hypStratification[topCell[Length[perm],permK[perm]]]//Select[#,hypDimension[#]==0&]&;
graph=points//Table[A1!=A2&&(Intersection[hypInverseStratification[#[[A1]]],hypInverseStratification[#[[A2]]]]//Select[#,hypDimension[#]==1&]&//Length[#]>0&),{A1,#//Length},{A2,#//Length}]&//Boole//GraphPlot3D[#,EdgeRenderingFunction->({drawColour[True],Cylinder[#1,.02]}&),VertexRenderingFunction->({EdgeForm[Black],{Black,Style[Text[Position[pointsAll,points[[#2]]][[1,1]],#1],FontSize->14,FontFamily->"Utopia"]},{drawColour[True],Sphere[#,0.18]}}&),VertexLabeling->All,ImageSize->250]&;
If[Not[OptionValue[showGraphics]]&& Not[OptionValue[showPermutations]],graph,
labels=points//Table[{ToString[Position[pointsAll,points[[A1]]][[1,1]]],"\[Rule]",If[OptionValue[showPermutations],ToString[#[[A1]]]],If[OptionValue[showGraphics],posPermToLeDiagram[#[[A1]]]]},{A1,#//Length}]&//Grid[#,Alignment->Left]&;
If[OptionValue[showGraphics],Grid[{{graph},{labels}}],Grid[{{graph,labels}}]]]
])/;((1<=permK[perm]<=Length[perm]-1)&&MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm]&&(1<=hypDimension[perm]<=3))

hypStratificationTo3D::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
hypStratificationTo3D::badargsIn=messages["badargs"][perm,"a cell in the hypersimplex"][2,0];
hypStratificationTo3D::badargsBound1=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypStratificationTo3D::badargsBound2=messages["badargs"]["bound"]["1\[LessEqual]hypDimension[perm]\[LessEqual]3"];
hypStratificationTo3D[perm_,___]:=(Message[hypStratificationTo3D::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
hypStratificationTo3D[perm_,___]:=(Message[hypStratificationTo3D::badargsIn];$Failed)/;Not[MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm]]
hypStratificationTo3D[perm_,___]:=(Message[hypStratificationTo3D::badargsBound1];$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]
hypStratificationTo3D[perm_,___]:=(Message[hypStratificationTo3D::badargsBound2];$Failed)/;Not[1<=hypDimension[perm]<=3]


(* ::Input::Initialization:: *)
drawFacetsPosition[n_/;IntegerQ[n]&&n>0][i_/;IntegerQ[i]&&i>0]:={Cos[2\[Pi] (i-1)/n-\[Pi] (n-2)/(2n)+\[Pi]/n],Sin[2\[Pi] (i-1)/n+-\[Pi](n-2)/(2n)+\[Pi]/n]}/;(i<=n)


(* ::Input::Initialization:: *)
Options[ampFacetsToGraph]=Options[ampStratificationToHasse];
ampFacetsToGraph[2,options:OptionsPattern[]][perm_/;legalListPermQ[perm]]:=Block[{boundaries,all,num,imagesize,labels,graph,n=Length[perm]},
boundaries=perm//ampBoundary[2];
all=Join[{perm},boundaries];
num=Length[boundaries];
imagesize=If[num==2,100,If[num==4,500,50(num+3)]];
labels=all//Table[A1->Placed[{
If[OptionValue[showPermutations],MaTeX["\{"<>ToString[#[[A1]]]<>"\}",Magnification->drawDefaults["Label Magnification"]]],
If[OptionValue[showGraphics],(#[[A1]]//ampPermToGraphic[2,showLabels->OptionValue[showLabels]])]},{Above,Center}],{A1,#//Length}]&;
graph=all//Table[MemberQ[ampStratification[2][#[[A1]]],#[[A2]]],{A1,#//Length},{A2,#//Length}]&//Boole//AdjacencyGraph//TransitiveReductionGraph//Graph[#,GraphLayout->"SpringElectricalEmbedding",VertexStyle->Directive[White,EdgeForm[{drawColour[False],Thickness[OptionValue[edgeScale] 1.5/imagesize]}]],
VertexSize->If[OptionValue[showGraphics],0.65(*+If[n\[Equal]4,0.18,0]*),0.1],
EdgeStyle->{Directive[Arrowheads[20/imagesize],drawColour[False],Thickness[OptionValue[edgeScale] 1.5/imagesize]]},
VertexLabels->labels,
ImageSize->imagesize,VertexCoordinates->Join[{{0,0}},Table[drawFacetsPosition[num][A1],{A1,num}]]]&;
If[OptionValue[rasterize],Rasterize[graph,ImageSize->imagesize,ImageResolution->OptionValue[imageResolution]],graph]
]/;(permK[perm]+2<=Length[perm]&&MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm]&&ampDimension[2][perm]>=1)

ampFacetsToGraph[perm_/;legalListPermQ[perm],options:OptionsPattern[]]:=ampFacetsToGraph[OptionValue[m],options][perm]

ampFacetsToGraph::badargsM=messages["badargs"]["implemented"]["m\[Equal]2"];
ampFacetsToGraph::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampFacetsToGraph::badargsIn=messages["badargs"][perm,"a cell in the amplituhedron"][2,0];
ampFacetsToGraph::badargsBound1=messages["badargs"]["bound"]["permK[perm]+2\[LessEqual]Length[perm]"];
ampFacetsToGraph::badargsBound2=messages["badargs"]["bound"]["ampDimension[2][perm]\[GreaterEqual]1"];
ampFacetsToGraph[m_,___][perm_]:=(Message[ampFacetsToGraph::badargsM];$Failed)/;Not[m==2]
ampFacetsToGraph[m_,___][perm_]:=(Message[ampFacetsToGraph::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampFacetsToGraph[m_,___][perm_]:=(Message[ampFacetsToGraph::badargsIn];$Failed)/;Not[MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm]]
ampFacetsToGraph[m_,___][perm_]:=(Message[ampFacetsToGraph::badargsBound1];$Failed)/;Not[permK[perm]+2<=Length[perm]]
ampFacetsToGraph[m_,___][perm_]:=(Message[ampFacetsToGraph::badargsBound2];$Failed)/;Not[ampDimension[2][perm]>=1]


(* ::Input::Initialization:: *)
Options[momFacetsToGraph]=Options[momStratificationToHasse];
momFacetsToGraph[m_/;MemberQ[{2,4},m],options:OptionsPattern[]][perm_/;legalListPermQ[perm]]:=Block[{boundaries,all,num,vertexsize,imagesize,labels,graph,n=Length[perm],k=permK[perm]},
boundaries=perm//momBoundary[m];
all=Join[{perm},boundaries];
num=Length[boundaries];
imagesize=50(num+3)(0.4+0.2Max[k,n-k]);
labels=all//Table[A1->Placed[{
If[OptionValue[showPermutations],MaTeX["\{"<>ToString[#[[A1]]]<>"\}",Magnification->drawDefaults["Label Magnification"]]],
If[OptionValue[showGraphics],(#[[A1]]//posPermToLeDiagram)]},{Above,Center}],{A1,#//Length}]&;
graph=all//Table[MemberQ[momStratification[m][#[[A1]]],#[[A2]]],{A1,#//Length},{A2,#//Length}]&//Boole//AdjacencyGraph//TransitiveReductionGraph//Graph[#,GraphLayout->"SpringElectricalEmbedding",VertexStyle->Directive[White,EdgeForm[{drawColour[False],Thickness[OptionValue[edgeScale] 1.5/imagesize]}]],
VertexSize->If[OptionValue[showGraphics],0.5+If[k==n-k,0.2,0]+If[num<=4,0.1,0],0.1],
EdgeStyle->{Directive[Arrowheads[20/imagesize],drawColour[False],Thickness[OptionValue[edgeScale] 1.5/imagesize]]},
VertexLabels->labels,
ImageSize->imagesize,VertexCoordinates->Join[{{0,0}},Table[drawFacetsPosition[num][A1],{A1,num}]]]&;
If[OptionValue[rasterize],Rasterize[graph,ImageSize->imagesize,ImageResolution->OptionValue[imageResolution]],graph]
]/;(m/2<=permK[perm]<=Length[perm]-m/2&&MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm]&&momDimension[m][perm]>=1)

momFacetsToGraph[perm_/;legalListPermQ[perm],options:OptionsPattern[]]:=momFacetsToGraph[OptionValue[m],options][perm]

momFacetsToGraph::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momFacetsToGraph::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
momFacetsToGraph::badargsIn=messages["badargs"][perm,"a cell in the momentum amplituhedron"][2,0];
momFacetsToGraph::badargsBound1=messages["badargs"]["bound"]["m/2\[LessEqual]permK[perm]\[LessEqual]Length[perm]-m/2"];
momFacetsToGraph::badargsBound2=messages["badargs"]["bound"]["momDimension[m][perm]\[GreaterEqual]1"];
momFacetsToGraph[m_,___][perm_]:=(Message[momFacetsToGraph::badargsM];$Failed)/;Not[MemberQ[{2,4},m]]
momFacetsToGraph[m_,___][perm_]:=(Message[momFacetsToGraph::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
momFacetsToGraph[m_,___][perm_]:=(Message[momFacetsToGraph::badargsIn];$Failed)/;Not[MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm]]
momFacetsToGraph[m_,___][perm_]:=(Message[momFacetsToGraph::badargsBound1];$Failed)/;Not[m/2<=permK[perm]<=Length[perm]-m/2]
momFacetsToGraph[m_,___][perm_]:=(Message[momFacetsToGraph::badargsBound2];$Failed)/;Not[momDimension[m][perm]>=1]


(* ::Input::Initialization:: *)
Options[hypFacetsToGraph]=Options[hypStratificationToHasse];
hypFacetsToGraph[perm_/;legalListPermQ[perm],options:OptionsPattern[]]:=Block[{boundaries,all,num,vertexsize,imagesize,labels,graph,n=Length[perm],k=permK[perm]},
boundaries=perm//hypBoundary;
all=Join[{perm},boundaries];
num=Length[boundaries];
imagesize=If[num==2,80,50(num+3)](0.4+0.2Max[k,n-k]);
labels=all//Table[A1->Placed[{
If[OptionValue[showPermutations],MaTeX["\{"<>ToString[#[[A1]]]<>"\}",Magnification->drawDefaults["Label Magnification"]]],
If[OptionValue[showGraphics],(#[[A1]]//posPermToLeDiagram)]},{Above,Center}],{A1,#//Length}]&;
graph=all//Table[MemberQ[hypStratification[#[[A1]]],#[[A2]]],{A1,#//Length},{A2,#//Length}]&//Boole//AdjacencyGraph//TransitiveReductionGraph//Graph[#,GraphLayout->"SpringElectricalEmbedding",VertexStyle->Directive[White,EdgeForm[{drawColour[False],Thickness[OptionValue[edgeScale] 1.5/imagesize]}]],
VertexSize->If[OptionValue[showGraphics],0.5+If[k==n-k,0.2,0]+If[num<=4,0.1,0],0.1],
EdgeStyle->{Directive[Arrowheads[20/imagesize],drawColour[False],Thickness[OptionValue[edgeScale] 1.5/imagesize]]},
VertexLabels->labels,
ImageSize->imagesize,VertexCoordinates->Join[{{0,0}},Table[drawFacetsPosition[num][A1],{A1,num}]]]&;
If[OptionValue[rasterize],Rasterize[graph,ImageSize->imagesize,ImageResolution->OptionValue[imageResolution]],graph]
]/;(1<=permK[perm]<=Length[perm]-1&&MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm]&&hypDimension[perm]>=1)

hypFacetsToGraph::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
hypFacetsToGraph::badargsIn=messages["badargs"][perm,"a cell in the hypersimplex"][2,0];
hypFacetsToGraph::badargsBound1=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypFacetsToGraph::badargsBound2=messages["badargs"]["bound"]["hypDimension[perm]\[GreaterEqual]1"];
hypFacetsToGraph[perm_,___]:=(Message[hypFacetsToGraph::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
hypFacetsToGraph[perm_,___]:=(Message[hypFacetsToGraph::badargsIn];$Failed)/;Not[MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm]]
hypFacetsToGraph[perm_,___]:=(Message[hypFacetsToGraph::badargsBound1];$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]
hypFacetsToGraph[perm_,___]:=(Message[hypFacetsToGraph::badargsBound2];$Failed)/;Not[hypDimension[perm]>=1]


(* ::Input::Initialization:: *)
ClearAll[ampStratificationToTable]
Options[ampStratificationToTable]={m->2,showPermutations->True,fancyPermutations->False,showLabels->True,graphicType->"polygon"};
ampStratificationToTable[2,options:OptionsPattern[]][perm_/;legalListPermQ[perm]]:=Block[{width,dim=ampDimension[2][perm],layers},
width=Min[Length[ampBoundary[2][perm]],8];
layers=perm//ampStratification[2]//Table[Select[#,ampDimension[2][#]==dim-A1&],{A1,0,dim}]&//Table[{dim-A1,Table[A2//If[OptionValue[graphicType]=="lediagram",posPermToLeDiagram[#],ampPermToGraphic[2,showLabels->OptionValue[showLabels]][#]]&//If[OptionValue[showPermutations]//If[BooleanQ[#],#,True]&,Grid[{{
If[OptionValue[fancyPermutations]//If[BooleanQ[#],#,False]&,MaTeX["\{"<>ToString[A2]<>"\}",Magnification->drawDefaults["Label Magnification"]],ToString[A2]]
},{#}}],#]&,{A2,#[[A1+1]]}]//ArrayReshape[#,{Ceiling[Length[#]/width],width}]&//DeleteCases[#,0]&/@#&//Grid[{#}]&/@#&//Grid[Transpose@{#}]&,Length[#[[A1+1]]]},{A1,0,dim}]&;
{"\\text{dim}_A","\\text{Amplituhedron Cells}","\\text{Count}"}//MaTeX[#,Magnification->2]&/@#&//Prepend[layers,#]&//Grid[#,Frame->All,Background->{{None,None},{drawColour[True],None}}]&
]/;((permK[perm]+2<=Length[perm])&&MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm])
ampStratificationToTable[perm_/;legalListPermQ[perm],options:OptionsPattern[]]:=ampStratificationToTable[OptionValue[m],options][perm]

ampStratificationToTable::badargsM=messages["badargs"]["implemented"]["m\[Equal]2"];
ampStratificationToTable::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
ampStratificationToTable::badargsIn=messages["badargs"][perm,"a cell in the amplituhedron"][2,0];
ampStratificationToTable::badargsBound=messages["badargs"]["bound"]["permK[perm]+2\[LessEqual]Length[perm]"];
ampStratificationToTable[m_,___][perm_]:=(Message[ampStratificationToTable::badargsM];$Failed)/;Not[m==2]
ampStratificationToTable[m_,___][perm_]:=(Message[ampStratificationToTable::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
ampStratificationToTable[m_,___][perm_]:=(Message[ampStratificationToTable::badargsIn];$Failed)/;Not[MemberQ[ampStratification[2][topCell[Length[perm],permK[perm]]],perm]]
ampStratificationToTable[m_,___][perm_]:=(Message[ampStratificationToTable::badargsBound];$Failed)/;Not[permK[perm]+2<=Length[perm]]


(* ::Input::Initialization:: *)
ClearAll[momStratificationToTable]
Options[momStratificationToTable]={m->4,showPermutations->True,fancyPermutations->False};
momStratificationToTable[m_/;MemberQ[{2,4},m],options:OptionsPattern[]][perm_/;legalListPermQ[perm]]:=Block[{n=Length[perm],k=permK[perm],width,dim=momDimension[m][perm],layers},
width=Length[momBoundary[m][perm]]//If[# Max[k,n-k]/6>5,5,#]&;
layers=perm//momStratification[m]//Table[Select[#,momDimension[m][#]==dim-A1&],{A1,0,dim}]&//Table[{dim-A1,Table[A2//posPermToLeDiagram//If[OptionValue[showPermutations]//If[BooleanQ[#],#,True]&,Grid[{{
If[OptionValue[fancyPermutations]//If[BooleanQ[#],#,False]&,MaTeX["\{"<>ToString[A2]<>"\}",Magnification->drawDefaults["Label Magnification"]],ToString[A2]]
},{#}}],#]&,{A2,#[[A1+1]]}]//ArrayReshape[#,{Ceiling[Length[#]/width],width}]&//DeleteCases[#,0]&/@#&//Grid[{#}]&/@#&//Grid[Transpose@{#}]&,Length[#[[A1+1]]]},{A1,0,dim}]&;
{"\\text{dim}_M","\\text{Momentum Amplituhedron Cells}","\\text{Count}"}//MaTeX[#,Magnification->2]&/@#&//Prepend[layers,#]&//Grid[#,Frame->All,Background->{{None,None},{drawColour[True],None}}]&
]/;((m/2<=permK[perm]<=Length[perm]-m/2)&&MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm])
momStratificationToTable[perm_/;legalListPermQ[perm],options:OptionsPattern[]]:=momStratificationToTable[OptionValue[m],options][perm]

momStratificationToTable::badargsM=messages["badargs"][m,"2 or 4"][1,0];
momStratificationToTable::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
momStratificationToTable::badargsIn=messages["badargs"][perm,"a cell in the momentum amplituhedron"][2,0];
momStratificationToTable::badargsBound=messages["badargs"]["bound"]["m/2\[LessEqual]permK[perm]\[LessEqual]Length[perm]-m/2"];
momStratificationToTable[m_,___][perm_]:=(Message[momStratificationToTable::badargsM];$Failed)/;Not[MemberQ[{2,4},m]]
momStratificationToTable[m_,___][perm_]:=(Message[momStratificationToTable::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
momStratificationToTable[m_,___][perm_]:=(Message[momStratificationToTable::badargsIn];$Failed)/;Not[MemberQ[momStratification[m][topCell[Length[perm],permK[perm]]],perm]]
momStratificationToTable[m_,___][perm_]:=(Message[momStratificationToTable::badargsBound];$Failed)/;Not[m/2<=permK[perm]<=Length[perm]-m/2]


(* ::Input::Initialization:: *)
ClearAll[hypStratificationToTable]
Options[hypStratificationToTable]={showPermutations->True,fancyPermutations->False};
hypStratificationToTable[perm_/;legalListPermQ[perm],OptionsPattern[]]:=Block[{n=Length[perm],k=permK[perm],width,dim=hypDimension[perm],layers},
width=Length[hypBoundary[perm]]//If[# Max[k,n-k]/6>5,5,#]&;
layers=perm//hypStratification//Table[Select[#,hypDimension[#]==dim-A1&],{A1,0,dim}]&//Table[{dim-A1,Table[A2//posPermToLeDiagram//If[OptionValue[showPermutations]//If[BooleanQ[#],#,True]&,Grid[{{
If[OptionValue[fancyPermutations]//If[BooleanQ[#],#,False]&,MaTeX["\{"<>ToString[A2]<>"\}",Magnification->drawDefaults["Label Magnification"]],ToString[A2]]
},{#}}],#]&,{A2,#[[A1+1]]}]//ArrayReshape[#,{Ceiling[Length[#]/width],width}]&//DeleteCases[#,0]&/@#&//Grid[{#}]&/@#&//Grid[Transpose@{#}]&,Length[#[[A1+1]]]},{A1,0,dim}]&;
{"\\text{dim}_M","\\text{Hypersimplex Cells}","\\text{Count}"}//MaTeX[#,Magnification->2]&/@#&//Prepend[layers,#]&//Grid[#,Frame->All,Background->{{None,None},{drawColour[True],None}}]&
]/;((1<=permK[perm]<=Length[perm]-1)&&MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm])

hypStratificationToTable::badargsPerm=messages["badargs"][perm,"an affine permutation"][2,0];
hypStratificationToTable::badargsIn=messages["badargs"][perm,"a cell in the hypersimplex"][2,0];
hypStratificationToTable::badargsBound=messages["badargs"]["bound"]["1\[LessEqual]permK[perm]\[LessEqual]Length[perm]-1"];
hypStratificationToTable[perm_,___]:=(Message[hypStratificationToTable::badargsPerm];$Failed)/;Not[legalListPermQ[perm]]
hypStratificationToTable[perm_,___]:=(Message[hypStratificationToTable::badargsIn];$Failed)/;Not[MemberQ[hypStratification[topCell[Length[perm],permK[perm]]],perm]]
hypStratificationToTable[perm_,___]:=(Message[hypStratificationToTable::badargsBound];$Failed)/;Not[1<=permK[perm]<=Length[perm]-1]


End[];
EndPackage[];
